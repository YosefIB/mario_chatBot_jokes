"use strict";

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTsConfigDefaults = exports.ComputeAsCommonRootOfFiles = exports.loadCompiler = exports.resolveAndLoadCompiler = exports.readConfig = exports.findAndReadConfig = void 0;

var path_1 = require("path");

var index_1 = require("./index");

var ts_internals_1 = require("./ts-internals");

var tsconfigs_1 = require("./tsconfigs");

var util_1 = require("./util");
/**
 * TypeScript compiler option values required by `ts-node` which cannot be overridden.
 */


var TS_NODE_COMPILER_OPTIONS = {
  sourceMap: true,
  inlineSourceMap: false,
  inlineSources: true,
  declaration: false,
  noEmit: false,
  outDir: '.ts-node'
};
/*
 * Do post-processing on config options to support `ts-node`.
 */

function fixConfig(ts, config) {
  // Delete options that *should not* be passed through.
  delete config.options.out;
  delete config.options.outFile;
  delete config.options.composite;
  delete config.options.declarationDir;
  delete config.options.declarationMap;
  delete config.options.emitDeclarationOnly; // Target ES5 output by default (instead of ES3).

  if (config.options.target === undefined) {
    config.options.target = ts.ScriptTarget.ES5;
  } // Target CommonJS modules by default (instead of magically switching to ES6 when the target is ES6).


  if (config.options.module === undefined) {
    config.options.module = ts.ModuleKind.CommonJS;
  }

  return config;
}
/** @internal */


function findAndReadConfig(rawOptions) {
  var _a, _b, _c, _d, _e;

  var cwd = (0, path_1.resolve)((_c = (_b = (_a = rawOptions.cwd) !== null && _a !== void 0 ? _a : rawOptions.dir) !== null && _b !== void 0 ? _b : index_1.DEFAULTS.cwd) !== null && _c !== void 0 ? _c : process.cwd());
  var compilerName = (_d = rawOptions.compiler) !== null && _d !== void 0 ? _d : index_1.DEFAULTS.compiler; // Compute minimum options to read the config file.

  var projectLocalResolveDir = (0, util_1.getBasePathForProjectLocalDependencyResolution)(undefined, rawOptions.projectSearchDir, rawOptions.project, cwd);

  var _resolveAndLoadCompil = resolveAndLoadCompiler(compilerName, projectLocalResolveDir),
      compiler = _resolveAndLoadCompil.compiler,
      ts = _resolveAndLoadCompil.ts; // Read config file and merge new options between env and CLI options.


  var _readConfig = readConfig(cwd, ts, rawOptions),
      configFilePath = _readConfig.configFilePath,
      config = _readConfig.config,
      tsNodeOptionsFromTsconfig = _readConfig.tsNodeOptionsFromTsconfig,
      optionBasePaths = _readConfig.optionBasePaths;

  var options = (0, util_1.assign)({}, index_1.DEFAULTS, tsNodeOptionsFromTsconfig || {}, {
    optionBasePaths: optionBasePaths
  }, rawOptions);
  options.require = [].concat(_toConsumableArray(tsNodeOptionsFromTsconfig.require || []), _toConsumableArray(rawOptions.require || [])); // Re-resolve the compiler in case it has changed.
  // Compiler is loaded relative to tsconfig.json, so tsconfig discovery may cause us to load a
  // different compiler than we did above, even if the name has not changed.

  if (configFilePath) {
    projectLocalResolveDir = (0, util_1.getBasePathForProjectLocalDependencyResolution)(configFilePath, rawOptions.projectSearchDir, rawOptions.project, cwd);

    var _resolveCompiler = resolveCompiler(options.compiler, (_e = optionBasePaths.compiler) !== null && _e !== void 0 ? _e : projectLocalResolveDir);

    compiler = _resolveCompiler.compiler;
  }

  return {
    options: options,
    config: config,
    projectLocalResolveDir: projectLocalResolveDir,
    optionBasePaths: optionBasePaths,
    configFilePath: configFilePath,
    cwd: cwd,
    compiler: compiler
  };
}

exports.findAndReadConfig = findAndReadConfig;
/**
 * Load TypeScript configuration. Returns the parsed TypeScript config and
 * any `ts-node` options specified in the config file.
 *
 * Even when a tsconfig.json is not loaded, this function still handles merging
 * compilerOptions from various sources: API, environment variables, etc.
 *
 * @internal
 */

function readConfig(cwd, ts, rawApiOptions) {
  var _a, _b, _c; // Ordered [a, b, c] where config a extends b extends c


  var configChain = [];
  var config = {
    compilerOptions: {}
  };
  var basePath = cwd;
  var configFilePath = undefined;
  var projectSearchDir = (0, path_1.resolve)(cwd, (_a = rawApiOptions.projectSearchDir) !== null && _a !== void 0 ? _a : cwd);
  var _rawApiOptions$fileEx = rawApiOptions.fileExists,
      fileExists = _rawApiOptions$fileEx === void 0 ? ts.sys.fileExists : _rawApiOptions$fileEx,
      _rawApiOptions$readFi = rawApiOptions.readFile,
      readFile = _rawApiOptions$readFi === void 0 ? ts.sys.readFile : _rawApiOptions$readFi,
      _rawApiOptions$skipPr = rawApiOptions.skipProject,
      skipProject = _rawApiOptions$skipPr === void 0 ? index_1.DEFAULTS.skipProject : _rawApiOptions$skipPr,
      _rawApiOptions$projec = rawApiOptions.project,
      project = _rawApiOptions$projec === void 0 ? index_1.DEFAULTS.project : _rawApiOptions$projec,
      _rawApiOptions$tsTrac = rawApiOptions.tsTrace,
      tsTrace = _rawApiOptions$tsTrac === void 0 ? index_1.DEFAULTS.tsTrace : _rawApiOptions$tsTrac; // Read project configuration when available.

  if (!skipProject) {
    if (project) {
      var resolved = (0, path_1.resolve)(cwd, project);
      var nested = (0, path_1.join)(resolved, 'tsconfig.json');
      configFilePath = fileExists(nested) ? nested : resolved;
    } else {
      configFilePath = ts.findConfigFile(projectSearchDir, fileExists);
    }

    if (configFilePath) {
      var pathToNextConfigInChain = configFilePath;
      var tsInternals = (0, ts_internals_1.createTsInternals)(ts);
      var errors = []; // Follow chain of "extends"

      while (true) {
        var result = ts.readConfigFile(pathToNextConfigInChain, readFile); // Return diagnostics.

        if (result.error) {
          return {
            configFilePath: configFilePath,
            config: {
              errors: [result.error],
              fileNames: [],
              options: {}
            },
            tsNodeOptionsFromTsconfig: {},
            optionBasePaths: {}
          };
        }

        var c = result.config;
        var bp = (0, path_1.dirname)(pathToNextConfigInChain);
        configChain.push({
          config: c,
          basePath: bp,
          configPath: pathToNextConfigInChain
        });
        if (c["extends"] == null) break;
        var resolvedExtendedConfigPath = tsInternals.getExtendsConfigPath(c["extends"], {
          fileExists: fileExists,
          readDirectory: ts.sys.readDirectory,
          readFile: readFile,
          useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,
          trace: tsTrace
        }, bp, errors, ts.createCompilerDiagnostic);

        if (errors.length) {
          return {
            configFilePath: configFilePath,
            config: {
              errors: errors,
              fileNames: [],
              options: {}
            },
            tsNodeOptionsFromTsconfig: {},
            optionBasePaths: {}
          };
        }

        if (resolvedExtendedConfigPath == null) break;
        pathToNextConfigInChain = resolvedExtendedConfigPath;
      }

      var _configChain$ = configChain[0];
      config = _configChain$.config;
      basePath = _configChain$.basePath;
    }
  } // Merge and fix ts-node options that come from tsconfig.json(s)


  var tsNodeOptionsFromTsconfig = {};
  var optionBasePaths = {};

  for (var i = configChain.length - 1; i >= 0; i--) {
    var _configChain$i = configChain[i],
        _config = _configChain$i.config,
        _basePath = _configChain$i.basePath,
        configPath = _configChain$i.configPath;
    var options = filterRecognizedTsConfigTsNodeOptions(_config['ts-node']).recognized; // Some options are relative to the config file, so must be converted to absolute paths here

    if (options.require) {
      (function () {
        // Modules are found relative to the tsconfig file, not the `dir` option
        var tsconfigRelativeResolver = (0, util_1.createProjectLocalResolveHelper)((0, path_1.dirname)(configPath));
        options.require = options.require.map(function (path) {
          return tsconfigRelativeResolver(path, false);
        });
      })();
    }

    if (options.scopeDir) {
      options.scopeDir = (0, path_1.resolve)(_basePath, options.scopeDir);
    } // Downstream code uses the basePath; we do not do that here.


    if (options.moduleTypes) {
      optionBasePaths.moduleTypes = _basePath;
    }

    if (options.transpiler != null) {
      optionBasePaths.transpiler = _basePath;
    }

    if (options.compiler != null) {
      optionBasePaths.compiler = _basePath;
    }

    if (options.swc != null) {
      optionBasePaths.swc = _basePath;
    }

    (0, util_1.assign)(tsNodeOptionsFromTsconfig, options);
  } // Remove resolution of "files".


  var files = (_c = (_b = rawApiOptions.files) !== null && _b !== void 0 ? _b : tsNodeOptionsFromTsconfig.files) !== null && _c !== void 0 ? _c : index_1.DEFAULTS.files; // Only if a config file is *not* loaded, load an implicit configuration from @tsconfig/bases

  var skipDefaultCompilerOptions = configFilePath != null;
  var defaultCompilerOptionsForNodeVersion = skipDefaultCompilerOptions ? undefined : _objectSpread({}, (0, tsconfigs_1.getDefaultTsconfigJsonForNodeVersion)(ts).compilerOptions, {
    types: ['node']
  }); // Merge compilerOptions from all sources

  config.compilerOptions = Object.assign({}, // automatically-applied options from @tsconfig/bases
  defaultCompilerOptionsForNodeVersion, // tsconfig.json "compilerOptions"
  config.compilerOptions, // from env var
  index_1.DEFAULTS.compilerOptions, // tsconfig.json "ts-node": "compilerOptions"
  tsNodeOptionsFromTsconfig.compilerOptions, // passed programmatically
  rawApiOptions.compilerOptions, // overrides required by ts-node, cannot be changed
  TS_NODE_COMPILER_OPTIONS);
  var fixedConfig = fixConfig(ts, ts.parseJsonConfigFileContent(config, {
    fileExists: fileExists,
    readFile: readFile,
    // Only used for globbing "files", "include", "exclude"
    // When `files` option disabled, we want to avoid the fs calls
    readDirectory: files ? ts.sys.readDirectory : function () {
      return [];
    },
    useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames
  }, basePath, undefined, configFilePath));
  return {
    configFilePath: configFilePath,
    config: fixedConfig,
    tsNodeOptionsFromTsconfig: tsNodeOptionsFromTsconfig,
    optionBasePaths: optionBasePaths
  };
}

exports.readConfig = readConfig;
/**
 * Load the typescript compiler. It is required to load the tsconfig but might
 * be changed by the tsconfig, so we have to do this twice.
 * @internal
 */

function resolveAndLoadCompiler(name, relativeToPath) {
  var _resolveCompiler2 = resolveCompiler(name, relativeToPath),
      compiler = _resolveCompiler2.compiler;

  var ts = loadCompiler(compiler);
  return {
    compiler: compiler,
    ts: ts
  };
}

exports.resolveAndLoadCompiler = resolveAndLoadCompiler;

function resolveCompiler(name, relativeToPath) {
  var projectLocalResolveHelper = (0, util_1.createProjectLocalResolveHelper)(relativeToPath);
  var compiler = projectLocalResolveHelper(name || 'typescript', true);
  return {
    compiler: compiler
  };
}
/** @internal */


function loadCompiler(compiler) {
  return (0, util_1.attemptRequireWithV8CompileCache)(require, compiler);
}

exports.loadCompiler = loadCompiler;
/**
 * Given the raw "ts-node" sub-object from a tsconfig, return an object with only the properties
 * recognized by "ts-node"
 */

function filterRecognizedTsConfigTsNodeOptions(jsonObject) {
  if (jsonObject == null) return {
    recognized: {},
    unrecognized: {}
  };

  var compiler = jsonObject.compiler,
      compilerHost = jsonObject.compilerHost,
      compilerOptions = jsonObject.compilerOptions,
      emit = jsonObject.emit,
      files = jsonObject.files,
      ignore = jsonObject.ignore,
      ignoreDiagnostics = jsonObject.ignoreDiagnostics,
      logError = jsonObject.logError,
      preferTsExts = jsonObject.preferTsExts,
      pretty = jsonObject.pretty,
      require = jsonObject.require,
      skipIgnore = jsonObject.skipIgnore,
      transpileOnly = jsonObject.transpileOnly,
      typeCheck = jsonObject.typeCheck,
      transpiler = jsonObject.transpiler,
      scope = jsonObject.scope,
      scopeDir = jsonObject.scopeDir,
      moduleTypes = jsonObject.moduleTypes,
      experimentalReplAwait = jsonObject.experimentalReplAwait,
      swc = jsonObject.swc,
      experimentalResolver = jsonObject.experimentalResolver,
      esm = jsonObject.esm,
      experimentalSpecifierResolution = jsonObject.experimentalSpecifierResolution,
      experimentalTsImportSpecifiers = jsonObject.experimentalTsImportSpecifiers,
      unrecognized = _objectWithoutProperties(jsonObject, ["compiler", "compilerHost", "compilerOptions", "emit", "files", "ignore", "ignoreDiagnostics", "logError", "preferTsExts", "pretty", "require", "skipIgnore", "transpileOnly", "typeCheck", "transpiler", "scope", "scopeDir", "moduleTypes", "experimentalReplAwait", "swc", "experimentalResolver", "esm", "experimentalSpecifierResolution", "experimentalTsImportSpecifiers"]);

  var filteredTsConfigOptions = {
    compiler: compiler,
    compilerHost: compilerHost,
    compilerOptions: compilerOptions,
    emit: emit,
    experimentalReplAwait: experimentalReplAwait,
    files: files,
    ignore: ignore,
    ignoreDiagnostics: ignoreDiagnostics,
    logError: logError,
    preferTsExts: preferTsExts,
    pretty: pretty,
    require: require,
    skipIgnore: skipIgnore,
    transpileOnly: transpileOnly,
    typeCheck: typeCheck,
    transpiler: transpiler,
    scope: scope,
    scopeDir: scopeDir,
    moduleTypes: moduleTypes,
    swc: swc,
    experimentalResolver: experimentalResolver,
    esm: esm,
    experimentalSpecifierResolution: experimentalSpecifierResolution,
    experimentalTsImportSpecifiers: experimentalTsImportSpecifiers
  }; // Use the typechecker to make sure this implementation has the correct set of properties

  var catchExtraneousProps = null;
  var catchMissingProps = null;
  return {
    recognized: filteredTsConfigOptions,
    unrecognized: unrecognized
  };
}
/** @internal */


exports.ComputeAsCommonRootOfFiles = Symbol();
/**
 * Some TS compiler options have defaults which are not provided by TS's config parsing functions.
 * This function centralizes the logic for computing those defaults.
 * @internal
 */

function getTsConfigDefaults(config, basePath, _files, _include, _exclude) {
  var _config$options$compo = config.options.composite,
      composite = _config$options$compo === void 0 ? false : _config$options$compo;
  var rootDir = config.options.rootDir;

  if (rootDir == null) {
    if (composite) rootDir = basePath; // Return this symbol to avoid computing from `files`, which would require fs calls
    else rootDir = exports.ComputeAsCommonRootOfFiles;
  }

  var _config$options$outDi = config.options.outDir,
      outDir = _config$options$outDi === void 0 ? rootDir : _config$options$outDi; // Docs are wrong: https://www.typescriptlang.org/tsconfig#include
  // Docs say **, but it's actually **/*; compiler throws error for **

  var include = _files ? [] : ['**/*'];
  var files = _files !== null && _files !== void 0 ? _files : []; // Docs are misleading: https://www.typescriptlang.org/tsconfig#exclude
  // Docs say it excludes node_modules, bower_components, jspm_packages, but actually those are excluded via behavior of "include"

  var exclude = _exclude !== null && _exclude !== void 0 ? _exclude : [outDir]; // TODO technically, outDir is absolute path, but exclude should be relative glob pattern?
  // TODO compute baseUrl

  return {
    rootDir: rootDir,
    outDir: outDir,
    include: include,
    files: files,
    exclude: exclude,
    composite: composite
  };
}

exports.getTsConfigDefaults = getTsConfigDefaults;