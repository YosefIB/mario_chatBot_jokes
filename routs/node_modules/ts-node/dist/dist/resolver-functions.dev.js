"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createResolverFunctions = void 0;

var path_1 = require("path");
/**
 * @internal
 * In a factory because these are shared across both CompilerHost and LanguageService codepaths
 */


function createResolverFunctions(kwargs) {
  var host = kwargs.host,
      ts = kwargs.ts,
      config = kwargs.config,
      cwd = kwargs.cwd,
      getCanonicalFileName = kwargs.getCanonicalFileName,
      projectLocalResolveHelper = kwargs.projectLocalResolveHelper,
      options = kwargs.options,
      extensions = kwargs.extensions;
  var moduleResolutionCache = ts.createModuleResolutionCache(cwd, getCanonicalFileName, config.options);
  var knownInternalFilenames = new Set();
  /** "Buckets" (module directories) whose contents should be marked "internal" */

  var internalBuckets = new Set(); // Get bucket for a source filename.  Bucket is the containing `./node_modules/*/` directory
  // For '/project/node_modules/foo/node_modules/bar/lib/index.js' bucket is '/project/node_modules/foo/node_modules/bar/'
  // For '/project/node_modules/foo/node_modules/@scope/bar/lib/index.js' bucket is '/project/node_modules/foo/node_modules/@scope/bar/'

  var moduleBucketRe = /.*\/node_modules\/(?:@[^\/]+\/)?[^\/]+\//;

  function getModuleBucket(filename) {
    var find = moduleBucketRe.exec(filename);
    if (find) return find[0];
    return '';
  } // Mark that this file and all siblings in its bucket should be "internal"


  function markBucketOfFilenameInternal(filename) {
    internalBuckets.add(getModuleBucket(filename));
  }

  function isFileInInternalBucket(filename) {
    return internalBuckets.has(getModuleBucket(filename));
  }

  function isFileKnownToBeInternal(filename) {
    return knownInternalFilenames.has(filename);
  }
  /**
   * If we need to emit JS for a file, force TS to consider it non-external
   */


  var fixupResolvedModule = function fixupResolvedModule(resolvedModule) {
    var resolvedFileName = resolvedModule.resolvedFileName;
    if (resolvedFileName === undefined) return; // [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]
    // .ts,.mts,.cts is always switched to internal
    // .js is switched on-demand

    if (resolvedModule.isExternalLibraryImport && (resolvedFileName.endsWith('.ts') && !resolvedFileName.endsWith('.d.ts') || resolvedFileName.endsWith('.cts') && !resolvedFileName.endsWith('.d.cts') || resolvedFileName.endsWith('.mts') && !resolvedFileName.endsWith('.d.mts') || isFileKnownToBeInternal(resolvedFileName) || isFileInInternalBucket(resolvedFileName))) {
      resolvedModule.isExternalLibraryImport = false;
    }

    if (!resolvedModule.isExternalLibraryImport) {
      knownInternalFilenames.add(resolvedFileName);
    }
  };
  /*
   * NOTE:
   * Older ts versions do not pass `redirectedReference` nor `options`.
   * We must pass `redirectedReference` to newer ts versions, but cannot rely on `options`, hence the weird argument name
   */


  var resolveModuleNames = function resolveModuleNames(moduleNames, containingFile, reusedNames, redirectedReference, optionsOnlyWithNewerTsVersions, containingSourceFile) {
    return moduleNames.map(function (moduleName, i) {
      var _a, _b;

      var mode = containingSourceFile ? (_b = (_a = ts).getModeForResolutionAtIndex) === null || _b === void 0 ? void 0 : _b.call(_a, containingSourceFile, i) : undefined;

      var _ts$resolveModuleName = ts.resolveModuleName(moduleName, containingFile, config.options, host, moduleResolutionCache, redirectedReference, mode),
          resolvedModule = _ts$resolveModuleName.resolvedModule;

      if (!resolvedModule && options.experimentalTsImportSpecifiers) {
        var lastDotIndex = moduleName.lastIndexOf('.');
        var ext = lastDotIndex >= 0 ? moduleName.slice(lastDotIndex) : '';

        if (ext) {
          var replacements = extensions.tsResolverEquivalents.get(ext);
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = (replacements !== null && replacements !== void 0 ? replacements : [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var replacementExt = _step.value;

              var _ts$resolveModuleName2 = ts.resolveModuleName(moduleName.slice(0, -ext.length) + replacementExt, containingFile, config.options, host, moduleResolutionCache, redirectedReference, mode);

              resolvedModule = _ts$resolveModuleName2.resolvedModule;
              if (resolvedModule) break;
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      }

      if (resolvedModule) {
        fixupResolvedModule(resolvedModule);
      }

      return resolvedModule;
    });
  }; // language service never calls this, but TS docs recommend that we implement it


  var getResolvedModuleWithFailedLookupLocationsFromCache = function getResolvedModuleWithFailedLookupLocationsFromCache(moduleName, containingFile, resolutionMode) {
    var ret = ts.resolveModuleNameFromCache(moduleName, containingFile, moduleResolutionCache, resolutionMode);

    if (ret && ret.resolvedModule) {
      fixupResolvedModule(ret.resolvedModule);
    }

    return ret;
  };

  var resolveTypeReferenceDirectives = function resolveTypeReferenceDirectives(typeDirectiveNames, containingFile, redirectedReference, options, containingFileMode // new impliedNodeFormat is accepted by compilerHost
  ) {
    // Note: seems to be called with empty typeDirectiveNames array for all files.
    // TODO consider using `ts.loadWithTypeDirectiveCache`
    return typeDirectiveNames.map(function (typeDirectiveName) {
      // Copy-pasted from TS source:
      var nameIsString = typeof typeDirectiveName === 'string';
      var mode = nameIsString ? undefined : ts.getModeForFileReference(typeDirectiveName, containingFileMode);
      var strName = nameIsString ? typeDirectiveName : typeDirectiveName.fileName.toLowerCase();

      var _ts$resolveTypeRefere = ts.resolveTypeReferenceDirective(strName, containingFile, config.options, host, redirectedReference, undefined, mode),
          resolvedTypeReferenceDirective = _ts$resolveTypeRefere.resolvedTypeReferenceDirective;

      if (typeDirectiveName === 'node' && !resolvedTypeReferenceDirective) {
        // Resolve @types/node relative to project first, then __dirname (copy logic from elsewhere / refactor into reusable function)
        var typesNodePackageJsonPath;

        try {
          typesNodePackageJsonPath = projectLocalResolveHelper('@types/node/package.json', true);
        } catch (_unused) {} // gracefully do nothing when @types/node is not installed for any reason


        if (typesNodePackageJsonPath) {
          var typeRoots = [(0, path_1.resolve)(typesNodePackageJsonPath, '../..')];

          var _ts$resolveTypeRefere2 = ts.resolveTypeReferenceDirective(typeDirectiveName, containingFile, _objectSpread({}, config.options, {
            typeRoots: typeRoots
          }), host, redirectedReference);

          resolvedTypeReferenceDirective = _ts$resolveTypeRefere2.resolvedTypeReferenceDirective;
        }
      }

      if (resolvedTypeReferenceDirective) {
        fixupResolvedModule(resolvedTypeReferenceDirective);
      }

      return resolvedTypeReferenceDirective;
    });
  };

  return {
    resolveModuleNames: resolveModuleNames,
    getResolvedModuleWithFailedLookupLocationsFromCache: getResolvedModuleWithFailedLookupLocationsFromCache,
    resolveTypeReferenceDirectives: resolveTypeReferenceDirectives,
    isFileKnownToBeInternal: isFileKnownToBeInternal,
    markBucketOfFilenameInternal: markBucketOfFilenameInternal
  };
}

exports.createResolverFunctions = createResolverFunctions;