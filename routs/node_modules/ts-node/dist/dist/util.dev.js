"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _a;

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.versionGteLt = exports.once = exports.getBasePathForProjectLocalDependencyResolution = exports.createProjectLocalResolveHelper = exports.attemptRequireWithV8CompileCache = exports.cachedLookup = exports.hasOwnProperty = exports.normalizeSlashes = exports.parse = exports.split = exports.assign = exports.yn = exports.createRequire = void 0;

var module_1 = require("module");

var ynModule = require("yn");

var path_1 = require("path");
/** @internal */


exports.createRequire = (_a = module_1.createRequire !== null && module_1.createRequire !== void 0 ? module_1.createRequire : module_1.createRequireFromPath) !== null && _a !== void 0 ? _a : require('create-require');
/**
 * Wrapper around yn module that returns `undefined` instead of `null`.
 * This is implemented by yn v4, but we're staying on v3 to avoid v4's node 10 requirement.
 * @internal
 */

function yn(value) {
  var _a;

  return (_a = ynModule(value)) !== null && _a !== void 0 ? _a : undefined;
}

exports.yn = yn;
/**
 * Like `Object.assign`, but ignores `undefined` properties.
 *
 * @internal
 */

function assign(initialValue) {
  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  for (var _i = 0, _sources = sources; _i < _sources.length; _i++) {
    var source = _sources[_i];

    for (var _i2 = 0, _Object$keys = Object.keys(source); _i2 < _Object$keys.length; _i2++) {
      var key = _Object$keys[_i2];
      var value = source[key];
      if (value !== undefined) initialValue[key] = value;
    }
  }

  return initialValue;
}

exports.assign = assign;
/**
 * Split a string array of values
 * and remove empty strings from the resulting array.
 * @internal
 */

function split(value) {
  return typeof value === 'string' ? value.split(/ *, */g).filter(function (v) {
    return v !== '';
  }) : undefined;
}

exports.split = split;
/**
 * Parse a string as JSON.
 * @internal
 */

function parse(value) {
  return typeof value === 'string' ? JSON.parse(value) : undefined;
}

exports.parse = parse;
var directorySeparator = '/';
var backslashRegExp = /\\/g;
/**
 * Replace backslashes with forward slashes.
 * @internal
 */

function normalizeSlashes(value) {
  return value.replace(backslashRegExp, directorySeparator);
}

exports.normalizeSlashes = normalizeSlashes;
/**
 * Safe `hasOwnProperty`
 * @internal
 */

function hasOwnProperty(object, property) {
  return Object.prototype.hasOwnProperty.call(object, property);
}

exports.hasOwnProperty = hasOwnProperty;
/**
 * Cached fs operation wrapper.
 */

function cachedLookup(fn) {
  var cache = new Map();
  return function (arg) {
    if (!cache.has(arg)) {
      var v = fn(arg);
      cache.set(arg, v);
      return v;
    }

    return cache.get(arg);
  };
}

exports.cachedLookup = cachedLookup;
/**
 * @internal
 * Require something with v8-compile-cache, which should make subsequent requires faster.
 * Do lots of error-handling so that, worst case, we require without the cache, and users are not blocked.
 */

function attemptRequireWithV8CompileCache(requireFn, specifier) {
  try {
    var v8CC = require('v8-compile-cache-lib').install();

    try {
      return requireFn(specifier);
    } finally {
      v8CC === null || v8CC === void 0 ? void 0 : v8CC.uninstall();
    }
  } catch (e) {
    return requireFn(specifier);
  }
}

exports.attemptRequireWithV8CompileCache = attemptRequireWithV8CompileCache;
/**
 * Helper to discover dependencies relative to a user's project, optionally
 * falling back to relative to ts-node.  This supports global installations of
 * ts-node, for example where someone does `#!/usr/bin/env -S ts-node --swc` and
 * we need to fallback to a global install of @swc/core
 * @internal
 */

function createProjectLocalResolveHelper(localDirectory) {
  return function projectLocalResolveHelper(specifier, fallbackToTsNodeRelative) {
    return require.resolve(specifier, {
      paths: fallbackToTsNodeRelative ? [localDirectory, __dirname] : [localDirectory]
    });
  };
}

exports.createProjectLocalResolveHelper = createProjectLocalResolveHelper;
/**
 * Used as a reminder of all the factors we must consider when finding project-local dependencies and when a config file
 * on disk may or may not exist.
 * @internal
 */

function getBasePathForProjectLocalDependencyResolution(configFilePath, projectSearchDirOption, projectOption, cwdOption) {
  var _a;

  if (configFilePath != null) return (0, path_1.dirname)(configFilePath);
  return (_a = projectSearchDirOption !== null && projectSearchDirOption !== void 0 ? projectSearchDirOption : projectOption) !== null && _a !== void 0 ? _a : cwdOption; // TODO technically breaks if projectOption is path to a file, not a directory,
  // and we attempt to resolve relative specifiers.  By the time we resolve relative specifiers,
  // should have configFilePath, so not reach this codepath.
}

exports.getBasePathForProjectLocalDependencyResolution = getBasePathForProjectLocalDependencyResolution;
/** @internal */

function once(fn) {
  var value;
  var ran = false;

  function onceFn() {
    if (ran) return value;
    value = fn.apply(void 0, arguments);
    ran = true;
    return value;
  }

  return onceFn;
}

exports.once = once;
/** @internal */

function versionGteLt(version, gteRequirement, ltRequirement) {
  var _parse = parse(version),
      _parse2 = _slicedToArray(_parse, 4),
      major = _parse2[0],
      minor = _parse2[1],
      patch = _parse2[2],
      extra = _parse2[3];

  var _parse3 = parse(gteRequirement),
      _parse4 = _slicedToArray(_parse3, 3),
      gteMajor = _parse4[0],
      gteMinor = _parse4[1],
      gtePatch = _parse4[2];

  var isGte = major > gteMajor || major === gteMajor && (minor > gteMinor || minor === gteMinor && patch >= gtePatch);
  var isLt = true;

  if (ltRequirement) {
    var _parse5 = parse(ltRequirement),
        _parse6 = _slicedToArray(_parse5, 3),
        ltMajor = _parse6[0],
        ltMinor = _parse6[1],
        ltPatch = _parse6[2];

    isLt = major < ltMajor || major === ltMajor && (minor < ltMinor || minor === ltMinor && patch < ltPatch);
  }

  return isGte && isLt;

  function parse(requirement) {
    return requirement.split(/[\.-]/).map(function (s) {
      return parseInt(s, 10);
    });
  }
}

exports.versionGteLt = versionGteLt;