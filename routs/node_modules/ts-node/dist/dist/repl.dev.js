"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setupContext = exports.createEvalAwarePartialHost = exports.EvalState = exports.createRepl = exports.REPL_NAME = exports.REPL_FILENAME = exports.STDIN_NAME = exports.STDIN_FILENAME = exports.EVAL_NAME = exports.EVAL_FILENAME = void 0;

var os_1 = require("os");

var path_1 = require("path");

var repl_1 = require("repl");

var vm_1 = require("vm");

var index_1 = require("./index");

var fs_1 = require("fs");

var console_1 = require("console");

var assert = require("assert");

var module_1 = require("module"); // Lazy-loaded.


var _processTopLevelAwait;

function getProcessTopLevelAwait() {
  if (_processTopLevelAwait === undefined) {
    var _require = require('../dist-raw/node-internal-repl-await');

    _processTopLevelAwait = _require.processTopLevelAwait;
  }

  return _processTopLevelAwait;
}

var diff;

function getDiffLines() {
  if (diff === undefined) {
    diff = require('diff');
  }

  return diff.diffLines;
}
/** @internal */


exports.EVAL_FILENAME = "[eval].ts";
/** @internal */

exports.EVAL_NAME = "[eval]";
/** @internal */

exports.STDIN_FILENAME = "[stdin].ts";
/** @internal */

exports.STDIN_NAME = "[stdin]";
/** @internal */

exports.REPL_FILENAME = '<repl>.ts';
/** @internal */

exports.REPL_NAME = '<repl>';
/**
 * Create a ts-node REPL instance.
 *
 * Pay close attention to the example below.  Today, the API requires a few lines
 * of boilerplate to correctly bind the `ReplService` to the ts-node `Service` and
 * vice-versa.
 *
 * Usage example:
 *
 *     const repl = tsNode.createRepl();
 *     const service = tsNode.create({...repl.evalAwarePartialHost});
 *     repl.setService(service);
 *     repl.start();
 *
 * @category REPL
 */

function createRepl() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var _a, _b, _c, _d, _e;

  var _options$ignoreDiagno = options.ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl,
      ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl = _options$ignoreDiagno === void 0 ? true : _options$ignoreDiagno;
  var service = options.service;
  var nodeReplServer; // If `useGlobal` is not true, then REPL creates a context when started.
  // This stores a reference to it or to `global`, whichever is used, after REPL has started.

  var context;
  var state = (_a = options.state) !== null && _a !== void 0 ? _a : new EvalState((0, path_1.join)(process.cwd(), exports.REPL_FILENAME));
  var evalAwarePartialHost = createEvalAwarePartialHost(state, options.composeWithEvalAwarePartialHost);
  var stdin = (_b = options.stdin) !== null && _b !== void 0 ? _b : process.stdin;
  var stdout = (_c = options.stdout) !== null && _c !== void 0 ? _c : process.stdout;
  var stderr = (_d = options.stderr) !== null && _d !== void 0 ? _d : process.stderr;

  var _console = stdout === process.stdout && stderr === process.stderr ? console : new console_1.Console(stdout, stderr);

  var replService = {
    state: (_e = options.state) !== null && _e !== void 0 ? _e : new EvalState((0, path_1.join)(process.cwd(), exports.EVAL_FILENAME)),
    setService: setService,
    evalCode: evalCode,
    evalCodeInternal: evalCodeInternal,
    nodeEval: nodeEval,
    evalAwarePartialHost: evalAwarePartialHost,
    start: start,
    startInternal: startInternal,
    stdin: stdin,
    stdout: stdout,
    stderr: stderr,
    console: _console
  };
  return replService;

  function setService(_service) {
    service = _service;

    if (ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl) {
      service.addDiagnosticFilter({
        appliesToAllFiles: false,
        filenamesAbsolute: [state.path],
        diagnosticsIgnored: [2393, 6133, 7027].concat(_toConsumableArray(service.shouldReplAwait ? topLevelAwaitDiagnosticCodes : []))
      });
    }
  }

  function evalCode(code) {
    var result = appendCompileAndEvalInput({
      service: service,
      state: state,
      input: code,
      context: context,
      overrideIsCompletion: false
    });
    assert(result.containsTopLevelAwait === false);
    return result.value;
  }

  function evalCodeInternal(options) {
    var code = options.code,
        enableTopLevelAwait = options.enableTopLevelAwait,
        context = options.context;
    return appendCompileAndEvalInput({
      service: service,
      state: state,
      input: code,
      enableTopLevelAwait: enableTopLevelAwait,
      context: context
    });
  }

  function nodeEval(code, context, _filename, callback) {
    // TODO: Figure out how to handle completion here.
    if (code === '.scope') {
      callback(null);
      return;
    }

    try {
      var evalResult = evalCodeInternal({
        code: code,
        enableTopLevelAwait: true,
        context: context
      });

      if (evalResult.containsTopLevelAwait) {
        (function _callee() {
          return regeneratorRuntime.async(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  _context.t0 = callback;
                  _context.next = 4;
                  return regeneratorRuntime.awrap(evalResult.valuePromise);

                case 4:
                  _context.t1 = _context.sent;
                  (0, _context.t0)(null, _context.t1);
                  _context.next = 11;
                  break;

                case 8:
                  _context.prev = 8;
                  _context.t2 = _context["catch"](0);
                  handleError(_context.t2);

                case 11:
                case "end":
                  return _context.stop();
              }
            }
          }, null, null, [[0, 8]]);
        })();
      } else {
        callback(null, evalResult.value);
      }
    } catch (error) {
      handleError(error);
    } // Log TSErrors, check if they're recoverable, log helpful hints for certain
    // well-known errors, and invoke `callback()`
    // TODO should evalCode API get the same error-handling benefits?


    function handleError(error) {
      var _a, _b; // Don't show TLA hint if the user explicitly disabled repl top level await


      var canLogTopLevelAwaitHint = service.options.experimentalReplAwait !== false && !service.shouldReplAwait;

      if (error instanceof index_1.TSError) {
        // Support recoverable compilations using >= node 6.
        if (repl_1.Recoverable && isRecoverable(error)) {
          callback(new repl_1.Recoverable(error));
          return;
        } else {
          _console.error(error);

          if (canLogTopLevelAwaitHint && error.diagnosticCodes.some(function (dC) {
            return topLevelAwaitDiagnosticCodes.includes(dC);
          })) {
            _console.error(getTopLevelAwaitHint());
          }

          callback(null);
        }
      } else {
        var _error = error;

        if (canLogTopLevelAwaitHint && _error instanceof SyntaxError && ((_a = _error.message) === null || _a === void 0 ? void 0 : _a.includes('await is only valid'))) {
          try {
            // Only way I know to make our hint appear after the error
            _error.message += "\n\n".concat(getTopLevelAwaitHint());
            _error.stack = (_b = _error.stack) === null || _b === void 0 ? void 0 : _b.replace(/(SyntaxError:.*)/, function (_, $1) {
              return "".concat($1, "\n\n").concat(getTopLevelAwaitHint());
            });
          } catch (_unused) {}
        }

        callback(_error);
      }
    }

    function getTopLevelAwaitHint() {
      return "Hint: REPL top-level await requires TypeScript version 3.8 or higher and target ES2018 or higher. You are using TypeScript ".concat(service.ts.version, " and target ").concat(service.ts.ScriptTarget[service.config.options.target], ".");
    }
  } // Note: `code` argument is deprecated


  function start(code) {
    startInternal({
      code: code
    });
  } // Note: `code` argument is deprecated


  function startInternal(options) {
    var _ref = options !== null && options !== void 0 ? options : {},
        code = _ref.code,
        _ref$forceToBeModule = _ref.forceToBeModule,
        forceToBeModule = _ref$forceToBeModule === void 0 ? true : _ref$forceToBeModule,
        optionsOverride = _objectWithoutProperties(_ref, ["code", "forceToBeModule"]); // TODO assert that `service` is set; remove all `service!` non-null assertions
    // Eval incoming code before the REPL starts.
    // Note: deprecated


    if (code) {
      try {
        evalCode("".concat(code, "\n"));
      } catch (err) {
        _console.error(err); // Note: should not be killing the process here, but this codepath is deprecated anyway


        process.exit(1);
      }
    } // In case the typescript compiler hasn't compiled anything yet,
    // make it run though compilation at least one time before
    // the REPL starts for a snappier user experience on startup.


    service === null || service === void 0 ? void 0 : service.compile('', state.path);
    var repl = (0, repl_1.start)(_objectSpread({
      prompt: '> ',
      input: replService.stdin,
      output: replService.stdout,
      // Mimicking node's REPL implementation: https://github.com/nodejs/node/blob/168b22ba073ee1cbf8d0bcb4ded7ff3099335d04/lib/internal/repl.js#L28-L30
      terminal: stdout.isTTY && !parseInt(index_1.env.NODE_NO_READLINE, 10),
      eval: nodeEval,
      useGlobal: true
    }, optionsOverride));
    nodeReplServer = repl;
    context = repl.context; // Bookmark the point where we should reset the REPL state.

    var resetEval = appendToEvalState(state, '');

    function reset() {
      resetEval(); // Hard fix for TypeScript forcing `Object.defineProperty(exports, ...)`.

      runInContext('exports = module.exports', state.path, context);

      if (forceToBeModule) {
        state.input += 'export {};void 0;\n';
      } // Declare node builtins.
      // Skip the same builtins as `addBuiltinLibsToObject`:
      //   those starting with _
      //   those containing /
      //   those that already exist as globals
      // Intentionally suppress type errors in case @types/node does not declare any of them, and because
      // `declare import` is technically invalid syntax.
      // Avoid this when in transpileOnly, because third-party transpilers may not handle `declare import`.


      if (!(service === null || service === void 0 ? void 0 : service.transpileOnly)) {
        state.input += "// @ts-ignore\n".concat(module_1.builtinModules.filter(function (name) {
          return !name.startsWith('_') && !name.includes('/') && !['console', 'module', 'process'].includes(name);
        }).map(function (name) {
          return "declare import ".concat(name, " = require('").concat(name, "')");
        }).join(';'), "\n");
      }
    }

    reset();
    repl.on('reset', reset);
    repl.defineCommand('type', {
      help: 'Check the type of a TypeScript identifier',
      action: function action(identifier) {
        if (!identifier) {
          repl.displayPrompt();
          return;
        }

        var undo = appendToEvalState(state, identifier);

        var _service$getTypeInfo = service.getTypeInfo(state.input, state.path, state.input.length),
            name = _service$getTypeInfo.name,
            comment = _service$getTypeInfo.comment;

        undo();
        if (name) repl.outputStream.write("".concat(name, "\n"));
        if (comment) repl.outputStream.write("".concat(comment, "\n"));
        repl.displayPrompt();
      }
    }); // Set up REPL history when available natively via node.js >= 11.

    if (repl.setupHistory) {
      var historyPath = index_1.env.TS_NODE_HISTORY || (0, path_1.join)((0, os_1.homedir)(), '.ts_node_repl_history');
      repl.setupHistory(historyPath, function (err) {
        if (!err) return;

        _console.error(err);

        process.exit(1);
      });
    }

    return repl;
  }
}

exports.createRepl = createRepl;
/**
 * Eval state management. Stores virtual `[eval].ts` file
 */

var EvalState = function EvalState(path) {
  _classCallCheck(this, EvalState);

  this.path = path;
  /** @internal */

  this.input = '';
  /** @internal */

  this.output = '';
  /** @internal */

  this.version = 0;
  /** @internal */

  this.lines = 0;
};

exports.EvalState = EvalState;

function createEvalAwarePartialHost(state, composeWith) {
  function readFile(path) {
    if (path === state.path) return state.input;
    if (composeWith === null || composeWith === void 0 ? void 0 : composeWith.readFile) return composeWith.readFile(path);

    try {
      return (0, fs_1.readFileSync)(path, 'utf8');
    } catch (err) {
      /* Ignore. */
    }
  }

  function fileExists(path) {
    if (path === state.path) return true;
    if (composeWith === null || composeWith === void 0 ? void 0 : composeWith.fileExists) return composeWith.fileExists(path);

    try {
      var stats = (0, fs_1.statSync)(path);
      return stats.isFile() || stats.isFIFO();
    } catch (err) {
      return false;
    }
  }

  return {
    readFile: readFile,
    fileExists: fileExists
  };
}

exports.createEvalAwarePartialHost = createEvalAwarePartialHost;
var sourcemapCommentRe = /\/\/# ?sourceMappingURL=\S+[\s\r\n]*$/;
/**
 * Evaluate the code snippet.
 *
 * Append it to virtual .ts file, compile, handle compiler errors, compute a diff of the JS, and eval any code that
 * appears as "added" in the diff.
 */

function appendCompileAndEvalInput(options) {
  var service = options.service,
      state = options.state,
      wrappedErr = options.wrappedErr,
      _options$enableTopLev = options.enableTopLevelAwait,
      enableTopLevelAwait = _options$enableTopLev === void 0 ? false : _options$enableTopLev,
      context = options.context,
      overrideIsCompletion = options.overrideIsCompletion;
  var input = options.input; // It's confusing for `{ a: 1 }` to be interpreted as a block statement
  // rather than an object literal. So, we first try to wrap it in
  // parentheses, so that it will be interpreted as an expression.
  // Based on https://github.com/nodejs/node/blob/c2e6822153bad023ab7ebd30a6117dcc049e475c/lib/repl.js#L413-L422

  var wrappedCmd = false;

  if (!wrappedErr && /^\s*{/.test(input) && !/;\s*$/.test(input)) {
    input = "(".concat(input.trim(), ")\n");
    wrappedCmd = true;
  }

  var lines = state.lines;
  var isCompletion = overrideIsCompletion !== null && overrideIsCompletion !== void 0 ? overrideIsCompletion : !/\n$/.test(input);
  var undo = appendToEvalState(state, input);
  var output; // Based on https://github.com/nodejs/node/blob/92573721c7cff104ccb82b6ed3e8aa69c4b27510/lib/repl.js#L457-L461

  function adjustUseStrict(code) {
    // "void 0" keeps the repl from returning "use strict" as the result
    // value for statements and declarations that don't return a value.
    return code.replace(/^"use strict";/, '"use strict"; void 0;');
  }

  try {
    output = service.compile(state.input, state.path, -lines);
  } catch (err) {
    undo();

    if (wrappedCmd) {
      if (err instanceof index_1.TSError && err.diagnosticCodes[0] === 2339) {
        // Ensure consistent and more sane behavior between { a: 1 }['b'] and ({ a: 1 }['b'])
        throw err;
      } // Unwrap and try again


      return appendCompileAndEvalInput(_objectSpread({}, options, {
        wrappedErr: err
      }));
    }

    if (wrappedErr) throw wrappedErr;
    throw err;
  }

  output = adjustUseStrict(output); // Note: REPL does not respect sourcemaps!
  // To properly do that, we'd need to prefix the code we eval -- which comes
  // from `diffLines` -- with newlines so that it's at the proper line numbers.
  // Then we'd need to ensure each bit of eval-ed code, if there are multiples,
  // has the sourcemap appended to it.
  // We might also need to integrate with our sourcemap hooks' cache; I'm not sure.

  var outputWithoutSourcemapComment = output.replace(sourcemapCommentRe, '');
  var oldOutputWithoutSourcemapComment = state.output.replace(sourcemapCommentRe, ''); // Use `diff` to check for new JavaScript to execute.

  var changes = getDiffLines()(oldOutputWithoutSourcemapComment, outputWithoutSourcemapComment);

  if (isCompletion) {
    undo();
  } else {
    state.output = output; // Insert a semicolon to make sure that the code doesn't interact with the next line,
    // for example to prevent `2\n+ 2` from producing 4.
    // This is safe since the output will not change since we can only get here with successful inputs,
    // and adding a semicolon to the end of a successful input won't ever change the output.

    state.input = state.input.replace(/([^\n\s])([\n\s]*)$/, function (all, lastChar, whitespace) {
      if (lastChar !== ';') return "".concat(lastChar, ";").concat(whitespace);
      return all;
    });
  }

  var commands = [];
  var containsTopLevelAwait = false; // Build a list of "commands": bits of JS code in the diff that must be executed.

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    var _loop = function _loop() {
      var change = _step.value;

      if (change.added) {
        if (enableTopLevelAwait && service.shouldReplAwait && change.value.indexOf('await') > -1) {
          var processTopLevelAwait = getProcessTopLevelAwait(); // Newline prevents comments to mess with wrapper

          var wrappedResult = processTopLevelAwait(change.value + '\n');

          if (wrappedResult !== null) {
            containsTopLevelAwait = true;
            commands.push({
              mustAwait: true,
              execCommand: function execCommand() {
                return runInContext(wrappedResult, state.path, context);
              }
            });
            return "continue";
          }
        }

        commands.push({
          execCommand: function execCommand() {
            return runInContext(change.value, state.path, context);
          }
        });
      }
    };

    for (var _iterator = changes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    } // Execute all commands asynchronously if necessary, returning the result or a
    // promise of the result.

  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (containsTopLevelAwait) {
    return {
      containsTopLevelAwait: containsTopLevelAwait,
      valuePromise: function _callee2() {
        var value, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, command, r;

        return regeneratorRuntime.async(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                _context2.prev = 3;
                _iterator2 = commands[Symbol.iterator]();

              case 5:
                if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                  _context2.next = 19;
                  break;
                }

                command = _step2.value;
                r = command.execCommand();

                if (!command.mustAwait) {
                  _context2.next = 14;
                  break;
                }

                _context2.next = 11;
                return regeneratorRuntime.awrap(r);

              case 11:
                _context2.t0 = _context2.sent;
                _context2.next = 15;
                break;

              case 14:
                _context2.t0 = r;

              case 15:
                value = _context2.t0;

              case 16:
                _iteratorNormalCompletion2 = true;
                _context2.next = 5;
                break;

              case 19:
                _context2.next = 25;
                break;

              case 21:
                _context2.prev = 21;
                _context2.t1 = _context2["catch"](3);
                _didIteratorError2 = true;
                _iteratorError2 = _context2.t1;

              case 25:
                _context2.prev = 25;
                _context2.prev = 26;

                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }

              case 28:
                _context2.prev = 28;

                if (!_didIteratorError2) {
                  _context2.next = 31;
                  break;
                }

                throw _iteratorError2;

              case 31:
                return _context2.finish(28);

              case 32:
                return _context2.finish(25);

              case 33:
                return _context2.abrupt("return", value);

              case 34:
              case "end":
                return _context2.stop();
            }
          }
        }, null, null, [[3, 21, 25, 33], [26,, 28, 32]]);
      }()
    };
  } else {
    return {
      containsTopLevelAwait: false,
      value: commands.reduce(function (_, c) {
        return c.execCommand();
      }, undefined)
    };
  }
}
/**
 * Low-level execution of JS code in context
 */


function runInContext(code, filename, context) {
  var script = new vm_1.Script(code, {
    filename: filename
  });

  if (context === undefined || context === global) {
    return script.runInThisContext();
  } else {
    return script.runInContext(context);
  }
}
/**
 * Append to the eval instance and return an undo function.
 */


function appendToEvalState(state, input) {
  var undoInput = state.input;
  var undoVersion = state.version;
  var undoOutput = state.output;
  var undoLines = state.lines;
  state.input += input;
  state.lines += lineCount(input);
  state.version++;
  return function () {
    state.input = undoInput;
    state.output = undoOutput;
    state.version = undoVersion;
    state.lines = undoLines;
  };
}
/**
 * Count the number of lines.
 */


function lineCount(value) {
  var count = 0;
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = value[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _char = _step3.value;

      if (_char === '\n') {
        count++;
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return count;
}
/**
 * TS diagnostic codes which are recoverable, meaning that the user likely entered an incomplete line of code
 * and should be prompted for the next.  For example, starting a multi-line for() loop and not finishing it.
 * null value means code is always recoverable.  `Set` means code is only recoverable when occurring alongside at least one
 * of the other codes.
 */


var RECOVERY_CODES = new Map([[1003, null], [1005, null], [1109, null], [1126, null], [1136, new Set([1005]) // happens when typing out an object literal or block scope across multiple lines: '{ foo: 123,'
], [1160, null], [1161, null], [2355, null], [2391, null], [7010, new Set([1005]) // happens when fn signature spread across multiple lines: 'function a(\nb: any\n) {'
]]);
/**
 * Diagnostic codes raised when using top-level await.
 * These are suppressed when top-level await is enabled.
 * When it is *not* enabled, these trigger a helpful hint about enabling top-level await.
 */

var topLevelAwaitDiagnosticCodes = [1375, 1378, 1431, 1432 // Top-level 'for await' loops are only allowed when the 'module' option is set to 'esnext' or 'system', and the 'target' option is set to 'es2017' or higher.
];
/**
 * Check if a function can recover gracefully.
 */

function isRecoverable(error) {
  return error.diagnosticCodes.every(function (code) {
    var deps = RECOVERY_CODES.get(code);
    return deps === null || deps && error.diagnosticCodes.some(function (code) {
      return deps.has(code);
    });
  });
}
/**
 * @internal
 * Set properties on `context` before eval-ing [stdin] or [eval] input.
 */


function setupContext(context, module, filenameAndDirname) {
  if (filenameAndDirname) {
    context.__dirname = '.';
    context.__filename = "[".concat(filenameAndDirname, "]");
  }

  context.module = module;
  context.exports = module.exports;
  context.require = module.require.bind(module);
}

exports.setupContext = setupContext;