#!/usr/bin/env node
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bootstrap = exports.main = void 0;

var path_1 = require("path");

var util_1 = require("util");

var Module = require("module");

var arg;

var util_2 = require("./util");

var repl_1 = require("./repl");

var index_1 = require("./index");

var node_internal_modules_cjs_helpers_1 = require("../dist-raw/node-internal-modules-cjs-helpers");

var spawn_child_1 = require("./child/spawn-child");

var configuration_1 = require("./configuration");
/**
 * Main `bin` functionality.
 *
 * This file is split into a chain of functions (phases), each one adding to a shared state object.
 * This is done so that the next function can either be invoked in-process or, if necessary, invoked in a child process.
 *
 * The functions are intentionally given uncreative names and left in the same order as the original code, to make a
 * smaller git diff.
 */


function main() {
  var argv = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.argv.slice(2);
  var entrypointArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var args = parseArgv(argv, entrypointArgs);
  var state = {
    shouldUseChildProcess: false,
    isInChildProcess: false,
    isCli: true,
    tsNodeScript: __filename,
    parseArgvResult: args
  };
  return bootstrap(state);
}

exports.main = main;
/** @internal */

function bootstrap(state) {
  if (!state.phase2Result) {
    state.phase2Result = phase2(state);

    if (state.shouldUseChildProcess && !state.isInChildProcess) {
      // Note: When transitioning into the child-process after `phase2`,
      // the updated working directory needs to be preserved.
      return (0, spawn_child_1.callInChild)(state);
    }
  }

  if (!state.phase3Result) {
    state.phase3Result = phase3(state);

    if (state.shouldUseChildProcess && !state.isInChildProcess) {
      // Note: When transitioning into the child-process after `phase2`,
      // the updated working directory needs to be preserved.
      return (0, spawn_child_1.callInChild)(state);
    }
  }

  return phase4(state);
}

exports.bootstrap = bootstrap;

function parseArgv(argv, entrypointArgs) {
  arg !== null && arg !== void 0 ? arg : arg = require('arg'); // HACK: technically, this function is not marked @internal so it's possible
  // that libraries in the wild are doing `require('ts-node/dist/bin').main({'--transpile-only': true})`
  // We can mark this function @internal in next major release.
  // For now, rewrite args to avoid a breaking change.

  entrypointArgs = _objectSpread({}, entrypointArgs);

  for (var _i = 0, _Object$keys = Object.keys(entrypointArgs); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    entrypointArgs[key.replace(/([a-z])-([a-z])/g, function (_$0, $1, $2) {
      return "".concat($1).concat($2.toUpperCase());
    })] = entrypointArgs[key];
  }

  var args = _objectSpread({}, entrypointArgs, {}, arg({
    // Node.js-like options.
    '--eval': String,
    '--interactive': Boolean,
    '--print': Boolean,
    '--require': [String],
    // CLI options.
    '--help': Boolean,
    '--cwdMode': Boolean,
    '--scriptMode': Boolean,
    '--version': arg.COUNT,
    '--showConfig': Boolean,
    '--esm': Boolean,
    // Project options.
    '--cwd': String,
    '--files': Boolean,
    '--compiler': String,
    '--compilerOptions': util_2.parse,
    '--project': String,
    '--ignoreDiagnostics': [String],
    '--ignore': [String],
    '--transpileOnly': Boolean,
    '--transpiler': String,
    '--swc': Boolean,
    '--typeCheck': Boolean,
    '--compilerHost': Boolean,
    '--pretty': Boolean,
    '--skipProject': Boolean,
    '--skipIgnore': Boolean,
    '--preferTsExts': Boolean,
    '--logError': Boolean,
    '--emit': Boolean,
    '--scope': Boolean,
    '--scopeDir': String,
    '--noExperimentalReplAwait': Boolean,
    '--experimentalSpecifierResolution': String,
    // Aliases.
    '-e': '--eval',
    '-i': '--interactive',
    '-p': '--print',
    '-r': '--require',
    '-h': '--help',
    '-s': '--script-mode',
    '-v': '--version',
    '-T': '--transpileOnly',
    '-H': '--compilerHost',
    '-I': '--ignore',
    '-P': '--project',
    '-C': '--compiler',
    '-D': '--ignoreDiagnostics',
    '-O': '--compilerOptions',
    '--dir': '--cwd',
    // Support both tsc-style camelCase and node-style hypen-case for *all* flags
    '--cwd-mode': '--cwdMode',
    '--script-mode': '--scriptMode',
    '--show-config': '--showConfig',
    '--compiler-options': '--compilerOptions',
    '--ignore-diagnostics': '--ignoreDiagnostics',
    '--transpile-only': '--transpileOnly',
    '--type-check': '--typeCheck',
    '--compiler-host': '--compilerHost',
    '--skip-project': '--skipProject',
    '--skip-ignore': '--skipIgnore',
    '--prefer-ts-exts': '--preferTsExts',
    '--log-error': '--logError',
    '--scope-dir': '--scopeDir',
    '--no-experimental-repl-await': '--noExperimentalReplAwait',
    '--experimental-specifier-resolution': '--experimentalSpecifierResolution'
  }, {
    argv: argv,
    stopAtPositional: true
  })); // Only setting defaults for CLI-specific flags
  // Anything passed to `register()` can be `undefined`; `create()` will apply
  // defaults.


  var cwdArg = args['--cwd'],
      _args$Help = args['--help'],
      help = _args$Help === void 0 ? false : _args$Help,
      scriptMode = args['--scriptMode'],
      cwdMode = args['--cwdMode'],
      _args$Version = args['--version'],
      version = _args$Version === void 0 ? 0 : _args$Version,
      showConfig = args['--showConfig'],
      _args$Require = args['--require'],
      argsRequire = _args$Require === void 0 ? [] : _args$Require,
      _args$Eval = args['--eval'],
      code = _args$Eval === void 0 ? undefined : _args$Eval,
      _args$Print = args['--print'],
      print = _args$Print === void 0 ? false : _args$Print,
      _args$Interactive = args['--interactive'],
      interactive = _args$Interactive === void 0 ? false : _args$Interactive,
      files = args['--files'],
      compiler = args['--compiler'],
      compilerOptions = args['--compilerOptions'],
      project = args['--project'],
      ignoreDiagnostics = args['--ignoreDiagnostics'],
      ignore = args['--ignore'],
      transpileOnly = args['--transpileOnly'],
      typeCheck = args['--typeCheck'],
      transpiler = args['--transpiler'],
      swc = args['--swc'],
      compilerHost = args['--compilerHost'],
      pretty = args['--pretty'],
      skipProject = args['--skipProject'],
      skipIgnore = args['--skipIgnore'],
      preferTsExts = args['--preferTsExts'],
      logError = args['--logError'],
      emit = args['--emit'],
      _args$Scope = args['--scope'],
      scope = _args$Scope === void 0 ? undefined : _args$Scope,
      _args$ScopeDir = args['--scopeDir'],
      scopeDir = _args$ScopeDir === void 0 ? undefined : _args$ScopeDir,
      noExperimentalReplAwait = args['--noExperimentalReplAwait'],
      experimentalSpecifierResolution = args['--experimentalSpecifierResolution'],
      esm = args['--esm'],
      restArgs = args._;
  return {
    // Note: argv and restArgs may be overwritten by child process
    argv: process.argv,
    restArgs: restArgs,
    cwdArg: cwdArg,
    help: help,
    scriptMode: scriptMode,
    cwdMode: cwdMode,
    version: version,
    showConfig: showConfig,
    argsRequire: argsRequire,
    code: code,
    print: print,
    interactive: interactive,
    files: files,
    compiler: compiler,
    compilerOptions: compilerOptions,
    project: project,
    ignoreDiagnostics: ignoreDiagnostics,
    ignore: ignore,
    transpileOnly: transpileOnly,
    typeCheck: typeCheck,
    transpiler: transpiler,
    swc: swc,
    compilerHost: compilerHost,
    pretty: pretty,
    skipProject: skipProject,
    skipIgnore: skipIgnore,
    preferTsExts: preferTsExts,
    logError: logError,
    emit: emit,
    scope: scope,
    scopeDir: scopeDir,
    noExperimentalReplAwait: noExperimentalReplAwait,
    experimentalSpecifierResolution: experimentalSpecifierResolution,
    esm: esm
  };
}

function phase2(payload) {
  var _payload$parseArgvRes = payload.parseArgvResult,
      help = _payload$parseArgvRes.help,
      version = _payload$parseArgvRes.version,
      cwdArg = _payload$parseArgvRes.cwdArg,
      esm = _payload$parseArgvRes.esm;

  if (help) {
    console.log("\nUsage: ts-node [options] [ -e script | script.ts ] [arguments]\n\nOptions:\n\n  -e, --eval [code]               Evaluate code\n  -p, --print                     Print result of `--eval`\n  -r, --require [path]            Require a node module before execution\n  -i, --interactive               Opens the REPL even if stdin does not appear to be a terminal\n\n  --esm                           Bootstrap with the ESM loader, enabling full ESM support\n  --swc                           Use the faster swc transpiler\n\n  -h, --help                      Print CLI usage\n  -v, --version                   Print module version information.  -vvv to print additional information\n  --showConfig                    Print resolved configuration and exit\n\n  -T, --transpileOnly             Use TypeScript's faster `transpileModule` or a third-party transpiler\n  -H, --compilerHost              Use TypeScript's compiler host API\n  -I, --ignore [pattern]          Override the path patterns to skip compilation\n  -P, --project [path]            Path to TypeScript JSON project file\n  -C, --compiler [name]           Specify a custom TypeScript compiler\n  --transpiler [name]             Specify a third-party, non-typechecking transpiler\n  -D, --ignoreDiagnostics [code]  Ignore TypeScript warnings by diagnostic code\n  -O, --compilerOptions [opts]    JSON object to merge with compiler options\n\n  --cwd                           Behave as if invoked within this working directory.\n  --files                         Load `files`, `include` and `exclude` from `tsconfig.json` on startup\n  --pretty                        Use pretty diagnostic formatter (usually enabled by default)\n  --cwdMode                       Use current directory instead of <script.ts> for config resolution\n  --skipProject                   Skip reading `tsconfig.json`\n  --skipIgnore                    Skip `--ignore` checks\n  --emit                          Emit output files into `.ts-node` directory\n  --scope                         Scope compiler to files within `scopeDir`.  Anything outside this directory is ignored.\n  --scopeDir                      Directory for `--scope`\n  --preferTsExts                  Prefer importing TypeScript files over JavaScript files\n  --logError                      Logs TypeScript errors to stderr instead of throwing exceptions\n  --noExperimentalReplAwait       Disable top-level await in REPL.  Equivalent to node's --no-experimental-repl-await\n  --experimentalSpecifierResolution [node|explicit]\n                                  Equivalent to node's --experimental-specifier-resolution\n");
    process.exit(0);
  } // Output project information.


  if (version === 1) {
    console.log("v".concat(index_1.VERSION));
    process.exit(0);
  }

  var cwd = cwdArg ? (0, path_1.resolve)(cwdArg) : process.cwd(); // If ESM is explicitly enabled through the flag, stage3 should be run in a child process
  // with the ESM loaders configured.

  if (esm) payload.shouldUseChildProcess = true;
  return {
    cwd: cwd
  };
}

function phase3(payload) {
  var _payload$parseArgvRes2 = payload.parseArgvResult,
      emit = _payload$parseArgvRes2.emit,
      files = _payload$parseArgvRes2.files,
      pretty = _payload$parseArgvRes2.pretty,
      transpileOnly = _payload$parseArgvRes2.transpileOnly,
      transpiler = _payload$parseArgvRes2.transpiler,
      noExperimentalReplAwait = _payload$parseArgvRes2.noExperimentalReplAwait,
      typeCheck = _payload$parseArgvRes2.typeCheck,
      swc = _payload$parseArgvRes2.swc,
      compilerHost = _payload$parseArgvRes2.compilerHost,
      ignore = _payload$parseArgvRes2.ignore,
      preferTsExts = _payload$parseArgvRes2.preferTsExts,
      logError = _payload$parseArgvRes2.logError,
      scriptMode = _payload$parseArgvRes2.scriptMode,
      cwdMode = _payload$parseArgvRes2.cwdMode,
      project = _payload$parseArgvRes2.project,
      skipProject = _payload$parseArgvRes2.skipProject,
      skipIgnore = _payload$parseArgvRes2.skipIgnore,
      compiler = _payload$parseArgvRes2.compiler,
      ignoreDiagnostics = _payload$parseArgvRes2.ignoreDiagnostics,
      compilerOptions = _payload$parseArgvRes2.compilerOptions,
      argsRequire = _payload$parseArgvRes2.argsRequire,
      scope = _payload$parseArgvRes2.scope,
      scopeDir = _payload$parseArgvRes2.scopeDir,
      esm = _payload$parseArgvRes2.esm,
      experimentalSpecifierResolution = _payload$parseArgvRes2.experimentalSpecifierResolution;
  var cwd = payload.phase2Result.cwd; // NOTE: When we transition to a child process for ESM, the entry-point script determined
  // here might not be the one used later in `phase4`. This can happen when we execute the
  // original entry-point but then the process forks itself using e.g. `child_process.fork`.
  // We will always use the original TS project in forked processes anyway, so it is
  // expected and acceptable to retrieve the entry-point information here in `phase2`.
  // See: https://github.com/TypeStrong/ts-node/issues/1812.

  var _getEntryPointInfo = getEntryPointInfo(payload),
      entryPointPath = _getEntryPointInfo.entryPointPath;

  var preloadedConfig = (0, configuration_1.findAndReadConfig)({
    cwd: cwd,
    emit: emit,
    files: files,
    pretty: pretty,
    transpileOnly: (transpileOnly !== null && transpileOnly !== void 0 ? transpileOnly : transpiler != null) ? true : undefined,
    experimentalReplAwait: noExperimentalReplAwait ? false : undefined,
    typeCheck: typeCheck,
    transpiler: transpiler,
    swc: swc,
    compilerHost: compilerHost,
    ignore: ignore,
    logError: logError,
    projectSearchDir: getProjectSearchDir(cwd, scriptMode, cwdMode, entryPointPath),
    project: project,
    skipProject: skipProject,
    skipIgnore: skipIgnore,
    compiler: compiler,
    ignoreDiagnostics: ignoreDiagnostics,
    compilerOptions: compilerOptions,
    require: argsRequire,
    scope: scope,
    scopeDir: scopeDir,
    preferTsExts: preferTsExts,
    esm: esm,
    experimentalSpecifierResolution: experimentalSpecifierResolution
  }); // If ESM is enabled through the parsed tsconfig, stage4 should be run in a child
  // process with the ESM loaders configured.

  if (preloadedConfig.options.esm) payload.shouldUseChildProcess = true;
  return {
    preloadedConfig: preloadedConfig
  };
}
/**
 * Determines the entry-point information from the argv and phase2 result. This
 * method will be invoked in two places:
 *
 *   1. In phase 3 to be able to find a project from the potential entry-point script.
 *   2. In phase 4 to determine the actual entry-point script.
 *
 * Note that we need to explicitly re-resolve the entry-point information in the final
 * stage because the previous stage information could be modified when the bootstrap
 * invocation transitioned into a child process for ESM.
 *
 * Stages before (phase 4) can and will be cached by the child process through the Brotli
 * configuration and entry-point information is only reliable in the final phase. More
 * details can be found in here: https://github.com/TypeStrong/ts-node/issues/1812.
 */


function getEntryPointInfo(state) {
  var _state$parseArgvResul = state.parseArgvResult,
      code = _state$parseArgvResul.code,
      interactive = _state$parseArgvResul.interactive,
      restArgs = _state$parseArgvResul.restArgs;
  var cwd = state.phase2Result.cwd;
  var isCli = state.isCli; // Figure out which we are executing: piped stdin, --eval, REPL, and/or entrypoint
  // This is complicated because node's behavior is complicated
  // `node -e code -i ./script.js` ignores -e

  var executeEval = code != null && !(interactive && restArgs.length);
  var executeEntrypoint = !executeEval && restArgs.length > 0;
  var executeRepl = !executeEntrypoint && (interactive || process.stdin.isTTY && !executeEval);
  var executeStdin = !executeEval && !executeRepl && !executeEntrypoint;
  /**
   * Unresolved. May point to a symlink, not realpath. May be missing file extension
   * NOTE: resolution relative to cwd option (not `process.cwd()`) is legacy backwards-compat; should be changed in next major: https://github.com/TypeStrong/ts-node/issues/1834
   */

  var entryPointPath = executeEntrypoint ? isCli ? (0, path_1.resolve)(cwd, restArgs[0]) : (0, path_1.resolve)(restArgs[0]) : undefined;
  return {
    executeEval: executeEval,
    executeEntrypoint: executeEntrypoint,
    executeRepl: executeRepl,
    executeStdin: executeStdin,
    entryPointPath: entryPointPath
  };
}

function phase4(payload) {
  var _process$execArgv;

  var _a, _b, _c, _d, _e, _f, _g;

  var isInChildProcess = payload.isInChildProcess,
      tsNodeScript = payload.tsNodeScript;
  var _payload$parseArgvRes3 = payload.parseArgvResult,
      version = _payload$parseArgvRes3.version,
      showConfig = _payload$parseArgvRes3.showConfig,
      restArgs = _payload$parseArgvRes3.restArgs,
      code = _payload$parseArgvRes3.code,
      print = _payload$parseArgvRes3.print,
      argv = _payload$parseArgvRes3.argv;
  var cwd = payload.phase2Result.cwd;
  var preloadedConfig = payload.phase3Result.preloadedConfig;

  var _getEntryPointInfo2 = getEntryPointInfo(payload),
      entryPointPath = _getEntryPointInfo2.entryPointPath,
      executeEntrypoint = _getEntryPointInfo2.executeEntrypoint,
      executeEval = _getEntryPointInfo2.executeEval,
      executeRepl = _getEntryPointInfo2.executeRepl,
      executeStdin = _getEntryPointInfo2.executeStdin;

  var evalStuff;
  var replStuff;
  var stdinStuff;
  var evalAwarePartialHost = undefined;

  if (executeEval) {
    var state = new repl_1.EvalState((0, path_1.join)(cwd, repl_1.EVAL_FILENAME));
    evalStuff = {
      state: state,
      repl: (0, repl_1.createRepl)({
        state: state,
        composeWithEvalAwarePartialHost: evalAwarePartialHost,
        ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl: false
      })
    };
    evalAwarePartialHost = evalStuff.repl.evalAwarePartialHost;

    // Create a local module instance based on `cwd`.
    var _module = evalStuff.module = new Module(repl_1.EVAL_NAME);

    _module.filename = evalStuff.state.path;
    _module.paths = Module._nodeModulePaths(cwd);
  }

  if (executeStdin) {
    var _state = new repl_1.EvalState((0, path_1.join)(cwd, repl_1.STDIN_FILENAME));

    stdinStuff = {
      state: _state,
      repl: (0, repl_1.createRepl)({
        state: _state,
        composeWithEvalAwarePartialHost: evalAwarePartialHost,
        ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl: false
      })
    };
    evalAwarePartialHost = stdinStuff.repl.evalAwarePartialHost;

    // Create a local module instance based on `cwd`.
    var _module2 = stdinStuff.module = new Module(repl_1.STDIN_NAME);

    _module2.filename = stdinStuff.state.path;
    _module2.paths = Module._nodeModulePaths(cwd);
  }

  if (executeRepl) {
    var _state2 = new repl_1.EvalState((0, path_1.join)(cwd, repl_1.REPL_FILENAME));

    replStuff = {
      state: _state2,
      repl: (0, repl_1.createRepl)({
        state: _state2,
        composeWithEvalAwarePartialHost: evalAwarePartialHost
      })
    };
    evalAwarePartialHost = replStuff.repl.evalAwarePartialHost;
  } // Register the TypeScript compiler instance.


  var service = (0, index_1.createFromPreloadedConfig)(_objectSpread({}, preloadedConfig, {
    options: _objectSpread({}, preloadedConfig.options, {
      readFile: (_a = evalAwarePartialHost === null || evalAwarePartialHost === void 0 ? void 0 : evalAwarePartialHost.readFile) !== null && _a !== void 0 ? _a : undefined,
      fileExists: (_b = evalAwarePartialHost === null || evalAwarePartialHost === void 0 ? void 0 : evalAwarePartialHost.fileExists) !== null && _b !== void 0 ? _b : undefined,
      tsTrace: index_1.DEFAULTS.tsTrace
    })
  }));
  (0, index_1.register)(service);
  if (isInChildProcess) require('./child/child-loader').lateBindHooks((0, index_1.createEsmHooks)(service)); // Bind REPL service to ts-node compiler service (chicken-and-egg problem)

  replStuff === null || replStuff === void 0 ? void 0 : replStuff.repl.setService(service);
  evalStuff === null || evalStuff === void 0 ? void 0 : evalStuff.repl.setService(service);
  stdinStuff === null || stdinStuff === void 0 ? void 0 : stdinStuff.repl.setService(service); // Output project information.

  if (version === 2) {
    console.log("ts-node v".concat(index_1.VERSION));
    console.log("node ".concat(process.version));
    console.log("compiler v".concat(service.ts.version));
    process.exit(0);
  }

  if (version >= 3) {
    console.log("ts-node v".concat(index_1.VERSION, " ").concat((0, path_1.dirname)(__dirname)));
    console.log("node ".concat(process.version));
    console.log("compiler v".concat(service.ts.version, " ").concat((_c = service.compilerPath) !== null && _c !== void 0 ? _c : ''));
    process.exit(0);
  }

  if (showConfig) {
    var ts = service.ts;

    if (typeof ts.convertToTSConfig !== 'function') {
      console.error('Error: --showConfig requires a typescript versions >=3.2 that support --showConfig');
      process.exit(1);
    }

    var moduleTypes = undefined;

    if (service.options.moduleTypes) {
      // Assumption: this codepath requires CLI invocation, so moduleTypes must have come from a tsconfig, not API.
      var showRelativeTo = (0, path_1.dirname)(service.configFilePath);
      moduleTypes = {};

      for (var _i2 = 0, _Object$entries = Object.entries(service.options.moduleTypes); _i2 < _Object$entries.length; _i2++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
            key = _Object$entries$_i[0],
            value = _Object$entries$_i[1];

        moduleTypes[(0, path_1.relative)(showRelativeTo, (0, path_1.resolve)((_d = service.options.optionBasePaths) === null || _d === void 0 ? void 0 : _d.moduleTypes, key))] = value;
      }
    }

    var json = _objectSpread(_defineProperty({}, 'ts-node', _objectSpread({}, service.options, {
      require: ((_e = service.options.require) === null || _e === void 0 ? void 0 : _e.length) ? service.options.require : undefined,
      moduleTypes: moduleTypes,
      optionBasePaths: undefined,
      compilerOptions: undefined,
      project: (_f = service.configFilePath) !== null && _f !== void 0 ? _f : service.options.project
    })), ts.convertToTSConfig(service.config, (_g = service.configFilePath) !== null && _g !== void 0 ? _g : (0, path_1.join)(cwd, 'ts-node-implicit-tsconfig.json'), service.ts.sys));

    console.log( // Assumes that all configuration options which can possibly be specified via the CLI are JSON-compatible.
    // If, in the future, we must log functions, for example readFile and fileExists, then we can implement a JSON
    // replacer function.
    JSON.stringify(json, null, 2));
    process.exit(0);
  } // Prepend `ts-node` arguments to CLI for child processes.


  (_process$execArgv = process.execArgv).push.apply(_process$execArgv, [tsNodeScript].concat(_toConsumableArray(argv.slice(2, argv.length - restArgs.length)))); // TODO this comes from BootstrapState


  process.argv = [process.argv[1]].concat(executeEntrypoint ? [entryPointPath] : []).concat(restArgs.slice(executeEntrypoint ? 1 : 0)); // Execute the main contents (either eval, script or piped).

  if (executeEntrypoint) {
    if (payload.isInChildProcess && (0, util_2.versionGteLt)(process.versions.node, '18.6.0')) {
      // HACK workaround node regression
      require('../dist-raw/runmain-hack.js').run(entryPointPath);
    } else {
      Module.runMain();
    }
  } else {
    // Note: eval and repl may both run, but never with stdin.
    // If stdin runs, eval and repl will not.
    if (executeEval) {
      (0, node_internal_modules_cjs_helpers_1.addBuiltinLibsToObject)(global);
      evalAndExitOnTsError(evalStuff.repl, evalStuff.module, code, print, 'eval');
    }

    if (executeRepl) {
      replStuff.repl.start();
    }

    if (executeStdin) {
      var buffer = code || '';
      process.stdin.on('data', function (chunk) {
        return buffer += chunk;
      });
      process.stdin.on('end', function () {
        evalAndExitOnTsError(stdinStuff.repl, stdinStuff.module, buffer, // `echo 123 | node -p` still prints 123
        print, 'stdin');
      });
    }
  }
}
/**
 * Get project search path from args.
 */


function getProjectSearchDir(cwd, scriptMode, cwdMode, scriptPath) {
  // Validate `--script-mode` / `--cwd-mode` / `--cwd` usage is correct.
  if (scriptMode && cwdMode) {
    throw new TypeError('--cwd-mode cannot be combined with --script-mode');
  }

  if (scriptMode && !scriptPath) {
    throw new TypeError('--script-mode must be used with a script name, e.g. `ts-node --script-mode <script.ts>`');
  }

  var doScriptMode = scriptMode === true ? true : cwdMode === true ? false : !!scriptPath;

  if (doScriptMode) {
    // Use node's own resolution behavior to ensure we follow symlinks.
    // scriptPath may omit file extension or point to a directory with or without package.json.
    // This happens before we are registered, so we tell node's resolver to consider ts, tsx, and jsx files.
    // In extremely rare cases, is is technically possible to resolve the wrong directory,
    // because we do not yet know preferTsExts, jsx, nor allowJs.
    // See also, justification why this will not happen in real-world situations:
    // https://github.com/TypeStrong/ts-node/pull/1009#issuecomment-613017081
    var exts = ['.js', '.jsx', '.ts', '.tsx'];
    var extsTemporarilyInstalled = [];

    for (var _i3 = 0, _exts = exts; _i3 < _exts.length; _i3++) {
      var _ext = _exts[_i3];

      if (!(0, util_2.hasOwnProperty)(require.extensions, _ext)) {
        extsTemporarilyInstalled.push(_ext);

        require.extensions[_ext] = function () {};
      }
    }

    try {
      return (0, path_1.dirname)(requireResolveNonCached(scriptPath));
    } finally {
      for (var _i4 = 0, _extsTemporarilyInsta = extsTemporarilyInstalled; _i4 < _extsTemporarilyInsta.length; _i4++) {
        var ext = _extsTemporarilyInsta[_i4];
        delete require.extensions[ext];
      }
    }
  }

  return cwd;
}

var guaranteedNonexistentDirectoryPrefix = (0, path_1.resolve)(__dirname, 'doesnotexist');
var guaranteedNonexistentDirectorySuffix = 0;
/**
 * require.resolve an absolute path, tricking node into *not* caching the results.
 * Necessary so that we do not pollute require.resolve cache prior to installing require.extensions
 *
 * Is a terrible hack, because node does not expose the necessary cache invalidation APIs
 * https://stackoverflow.com/questions/59865584/how-to-invalidate-cached-require-resolve-results
 */

function requireResolveNonCached(absoluteModuleSpecifier) {
  // node <= 12.1.x fallback: The trick below triggers a node bug on old versions.
  // On these old versions, pollute the require cache instead. This is a deliberate
  // ts-node limitation that will *rarely* manifest, and will not matter once node 12
  // is end-of-life'd on 2022-04-30
  var isSupportedNodeVersion = (0, util_2.versionGteLt)(process.versions.node, '12.2.0');
  if (!isSupportedNodeVersion) return require.resolve(absoluteModuleSpecifier);

  var _ref = (0, path_1.parse)(absoluteModuleSpecifier),
      dir = _ref.dir,
      base = _ref.base;

  var relativeModuleSpecifier = "./".concat(base);
  var req = (0, util_2.createRequire)((0, path_1.join)(dir, 'imaginaryUncacheableRequireResolveScript'));
  return req.resolve(relativeModuleSpecifier, {
    paths: ["".concat(guaranteedNonexistentDirectoryPrefix).concat(guaranteedNonexistentDirectorySuffix++)].concat(_toConsumableArray(req.resolve.paths(relativeModuleSpecifier) || []))
  });
}
/**
 * Evaluate an [eval] or [stdin] script
 */


function evalAndExitOnTsError(replService, module, code, isPrinted, filenameAndDirname) {
  var result;
  (0, repl_1.setupContext)(global, module, filenameAndDirname);

  try {
    result = replService.evalCode(code);
  } catch (error) {
    if (error instanceof index_1.TSError) {
      console.error(error);
      process.exit(1);
    }

    throw error;
  }

  if (isPrinted) {
    console.log(typeof result === 'string' ? result : (0, util_1.inspect)(result, {
      colors: process.stdout.isTTY
    }));
  }
}

if (require.main === module) {
  main();
}