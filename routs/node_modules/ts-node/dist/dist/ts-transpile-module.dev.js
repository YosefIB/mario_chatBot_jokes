"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTsTranspileModule = void 0;
/** @internal */

function createTsTranspileModule(ts, transpileOptions) {
  var createProgram = ts.createProgram,
      createSourceFile = ts.createSourceFile,
      getDefaultCompilerOptions = ts.getDefaultCompilerOptions,
      getImpliedNodeFormatForFile = ts.getImpliedNodeFormatForFile,
      fixupCompilerOptions = ts.fixupCompilerOptions,
      transpileOptionValueCompilerOptions = ts.transpileOptionValueCompilerOptions,
      getNewLineCharacter = ts.getNewLineCharacter,
      fileExtensionIs = ts.fileExtensionIs,
      normalizePath = ts.normalizePath,
      Debug = ts.Debug,
      toPath = ts.toPath,
      getSetExternalModuleIndicator = ts.getSetExternalModuleIndicator,
      getEntries = ts.getEntries,
      addRange = ts.addRange,
      hasProperty = ts.hasProperty,
      getEmitScriptTarget = ts.getEmitScriptTarget,
      getDirectoryPath = ts.getDirectoryPath;
  var compilerOptionsDiagnostics = [];
  var options = transpileOptions.compilerOptions ? fixupCompilerOptions(transpileOptions.compilerOptions, compilerOptionsDiagnostics) : {}; // mix in default options

  var defaultOptions = getDefaultCompilerOptions();

  for (var key in defaultOptions) {
    if (hasProperty(defaultOptions, key) && options[key] === undefined) {
      options[key] = defaultOptions[key];
    }
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = transpileOptionValueCompilerOptions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var option = _step.value;
      options[option.name] = option.transpileOptionValue;
    } // transpileModule does not write anything to disk so there is no need to verify that there are no conflicts between input and output paths.

  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  options.suppressOutputPathCheck = true; // Filename can be non-ts file.

  options.allowNonTsExtensions = true;
  var newLine = getNewLineCharacter(options); // Create a compilerHost object to allow the compiler to read and write files

  var compilerHost = {
    getSourceFile: function getSourceFile(fileName) {
      return fileName === normalizePath(inputFileName) ? sourceFile : undefined;
    },
    writeFile: function writeFile(name, text) {
      if (fileExtensionIs(name, '.map')) {
        Debug.assertEqual(sourceMapText, undefined, 'Unexpected multiple source map outputs, file:', name);
        sourceMapText = text;
      } else {
        Debug.assertEqual(outputText, undefined, 'Unexpected multiple outputs, file:', name);
        outputText = text;
      }
    },
    getDefaultLibFileName: function getDefaultLibFileName() {
      return 'lib.d.ts';
    },
    useCaseSensitiveFileNames: function useCaseSensitiveFileNames() {
      return true;
    },
    getCanonicalFileName: function getCanonicalFileName(fileName) {
      return fileName;
    },
    getCurrentDirectory: function getCurrentDirectory() {
      return '';
    },
    getNewLine: function getNewLine() {
      return newLine;
    },
    fileExists: function fileExists(fileName) {
      return fileName === inputFileName || fileName === packageJsonFileName;
    },
    readFile: function readFile(fileName) {
      return fileName === packageJsonFileName ? "{\"type\": \"".concat(_packageJsonType, "\"}") : '';
    },
    directoryExists: function directoryExists() {
      return true;
    },
    getDirectories: function getDirectories() {
      return [];
    }
  };
  var inputFileName;
  var packageJsonFileName;

  var _packageJsonType;

  var sourceFile;
  var outputText;
  var sourceMapText;
  return transpileModule;

  function transpileModule(input, transpileOptions2) {
    var packageJsonType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'commonjs';
    // if jsx is specified then treat file as .tsx
    inputFileName = transpileOptions2.fileName || (transpileOptions.compilerOptions && transpileOptions.compilerOptions.jsx ? 'module.tsx' : 'module.ts');
    packageJsonFileName = getDirectoryPath(inputFileName) + '/package.json';
    _packageJsonType = packageJsonType;
    sourceFile = createSourceFile(inputFileName, input, {
      languageVersion: getEmitScriptTarget(options),
      impliedNodeFormat: getImpliedNodeFormatForFile(toPath(inputFileName, '', compilerHost.getCanonicalFileName),
      /*cache*/
      undefined, compilerHost, options),
      setExternalModuleIndicator: getSetExternalModuleIndicator(options)
    });

    if (transpileOptions2.moduleName) {
      sourceFile.moduleName = transpileOptions2.moduleName;
    }

    if (transpileOptions2.renamedDependencies) {
      sourceFile.renamedDependencies = new Map(getEntries(transpileOptions2.renamedDependencies));
    } // Output


    outputText = undefined;
    sourceMapText = undefined;
    var program = createProgram([inputFileName], options, compilerHost);
    var diagnostics = compilerOptionsDiagnostics.slice();

    if (transpileOptions.reportDiagnostics) {
      addRange(
      /*to*/
      diagnostics,
      /*from*/
      program.getSyntacticDiagnostics(sourceFile));
      addRange(
      /*to*/
      diagnostics,
      /*from*/
      program.getOptionsDiagnostics());
    } // Emit


    program.emit(
    /*targetSourceFile*/
    undefined,
    /*writeFile*/
    undefined,
    /*cancellationToken*/
    undefined,
    /*emitOnlyDtsFiles*/
    undefined, transpileOptions.transformers);
    if (outputText === undefined) return Debug.fail('Output generation failed');
    return {
      outputText: outputText,
      diagnostics: diagnostics,
      sourceMapText: sourceMapText
    };
  }
}

exports.createTsTranspileModule = createTsTranspileModule;