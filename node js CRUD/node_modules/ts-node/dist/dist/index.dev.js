"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _a, _b;

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createEsmHooks = exports.createFromPreloadedConfig = exports.create = exports.register = exports.TSError = exports.DEFAULTS = exports.VERSION = exports.debug = exports.INSPECT_CUSTOM = exports.env = exports.REGISTER_INSTANCE = exports.createRepl = void 0;

var path_1 = require("path");

var module_1 = require("module");

var util = require("util");

var url_1 = require("url");

var make_error_1 = require("make-error");

var util_1 = require("./util");

var configuration_1 = require("./configuration");

var module_type_classifier_1 = require("./module-type-classifier");

var resolver_functions_1 = require("./resolver-functions");

var cjs_resolve_hooks_1 = require("./cjs-resolve-hooks");

var node_module_type_classifier_1 = require("./node-module-type-classifier");

var file_extensions_1 = require("./file-extensions");

var ts_transpile_module_1 = require("./ts-transpile-module");

var repl_1 = require("./repl");

Object.defineProperty(exports, "createRepl", {
  enumerable: true,
  get: function get() {
    return repl_1.createRepl;
  }
});
/**
 * Does this version of node obey the package.json "type" field
 * and throw ERR_REQUIRE_ESM when attempting to require() an ESM modules.
 */

var engineSupportsPackageTypeField = parseInt(process.versions.node.split('.')[0], 10) >= 12;
/**
 * Assert that script can be loaded as CommonJS when we attempt to require it.
 * If it should be loaded as ESM, throw ERR_REQUIRE_ESM like node does.
 *
 * Loaded conditionally so we don't need to support older node versions
 */

var assertScriptCanLoadAsCJS = engineSupportsPackageTypeField ? require('../dist-raw/node-internal-modules-cjs-loader').assertScriptCanLoadAsCJSImpl : function () {
  /* noop */
};
/**
 * Registered `ts-node` instance information.
 */

exports.REGISTER_INSTANCE = Symbol["for"]('ts-node.register.instance');
/** @internal */

exports.env = process.env;
/**
 * @internal
 */

exports.INSPECT_CUSTOM = util.inspect.custom || 'inspect';
/**
 * Debugging `ts-node`.
 */

var shouldDebug = (0, util_1.yn)(exports.env.TS_NODE_DEBUG);
/** @internal */

exports.debug = shouldDebug ? function () {
  var _console;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (_console = console).log.apply(_console, ["[ts-node ".concat(new Date().toISOString(), "]")].concat(args));
} : function () {
  return undefined;
};
var debugFn = shouldDebug ? function (key, fn) {
  var i = 0;
  return function (x) {
    (0, exports.debug)(key, x, ++i);
    return fn(x);
  };
} : function (_, fn) {
  return fn;
};
/**
 * Export the current version.
 */

exports.VERSION = require('../package.json').version;
/**
 * Default register options, including values specified via environment
 * variables.
 * @internal
 */

exports.DEFAULTS = {
  cwd: (_a = exports.env.TS_NODE_CWD) !== null && _a !== void 0 ? _a : exports.env.TS_NODE_DIR,
  emit: (0, util_1.yn)(exports.env.TS_NODE_EMIT),
  scope: (0, util_1.yn)(exports.env.TS_NODE_SCOPE),
  scopeDir: exports.env.TS_NODE_SCOPE_DIR,
  files: (0, util_1.yn)(exports.env.TS_NODE_FILES),
  pretty: (0, util_1.yn)(exports.env.TS_NODE_PRETTY),
  compiler: exports.env.TS_NODE_COMPILER,
  compilerOptions: (0, util_1.parse)(exports.env.TS_NODE_COMPILER_OPTIONS),
  ignore: (0, util_1.split)(exports.env.TS_NODE_IGNORE),
  project: exports.env.TS_NODE_PROJECT,
  skipProject: (0, util_1.yn)(exports.env.TS_NODE_SKIP_PROJECT),
  skipIgnore: (0, util_1.yn)(exports.env.TS_NODE_SKIP_IGNORE),
  preferTsExts: (0, util_1.yn)(exports.env.TS_NODE_PREFER_TS_EXTS),
  ignoreDiagnostics: (0, util_1.split)(exports.env.TS_NODE_IGNORE_DIAGNOSTICS),
  transpileOnly: (0, util_1.yn)(exports.env.TS_NODE_TRANSPILE_ONLY),
  typeCheck: (0, util_1.yn)(exports.env.TS_NODE_TYPE_CHECK),
  compilerHost: (0, util_1.yn)(exports.env.TS_NODE_COMPILER_HOST),
  logError: (0, util_1.yn)(exports.env.TS_NODE_LOG_ERROR),
  experimentalReplAwait: (_b = (0, util_1.yn)(exports.env.TS_NODE_EXPERIMENTAL_REPL_AWAIT)) !== null && _b !== void 0 ? _b : undefined,
  tsTrace: console.log.bind(console)
};
/**
 * TypeScript diagnostics error.
 */

var TSError =
/*#__PURE__*/
function (_make_error_1$BaseErr) {
  _inherits(TSError, _make_error_1$BaseErr);

  function TSError(diagnosticText, diagnosticCodes) {
    var _this;

    var diagnostics = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    _classCallCheck(this, TSError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TSError).call(this, "\u2A2F Unable to compile TypeScript:\n".concat(diagnosticText)));
    _this.diagnosticCodes = diagnosticCodes;
    _this.name = 'TSError';
    Object.defineProperty(_assertThisInitialized(_this), 'diagnosticText', {
      configurable: true,
      writable: true,
      value: diagnosticText
    });
    Object.defineProperty(_assertThisInitialized(_this), 'diagnostics', {
      configurable: true,
      writable: true,
      value: diagnostics
    });
    return _this;
  }
  /**
   * @internal
   */


  _createClass(TSError, [{
    key: exports.INSPECT_CUSTOM,
    value: function value() {
      return this.diagnosticText;
    }
  }]);

  return TSError;
}(make_error_1.BaseError);

exports.TSError = TSError;
var TS_NODE_SERVICE_BRAND = Symbol('TS_NODE_SERVICE_BRAND');

function register(serviceOrOpts) {
  // Is this a Service or a RegisterOptions?
  var service = serviceOrOpts;

  if (!(serviceOrOpts === null || serviceOrOpts === void 0 ? void 0 : serviceOrOpts[TS_NODE_SERVICE_BRAND])) {
    // Not a service; is options
    service = create(serviceOrOpts !== null && serviceOrOpts !== void 0 ? serviceOrOpts : {});
  }

  var originalJsHandler = require.extensions['.js']; // Expose registered instance globally.

  process[exports.REGISTER_INSTANCE] = service; // Register the extensions.

  registerExtensions(service.options.preferTsExts, service.extensions.compiled, service, originalJsHandler);
  (0, cjs_resolve_hooks_1.installCommonjsResolveHooksIfNecessary)(service); // Require specified modules before start-up.

  module_1.Module._preloadModules(service.options.require);

  return service;
}

exports.register = register;
/**
 * Create TypeScript compiler instance.
 *
 * @category Basic
 */

function create() {
  var rawOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var foundConfigResult = (0, configuration_1.findAndReadConfig)(rawOptions);
  return createFromPreloadedConfig(foundConfigResult);
}

exports.create = create;
/** @internal */

function createFromPreloadedConfig(foundConfigResult) {
  var _ref5;

  var _a, _b, _c, _d;

  var configFilePath = foundConfigResult.configFilePath,
      cwd = foundConfigResult.cwd,
      options = foundConfigResult.options,
      config = foundConfigResult.config,
      compiler = foundConfigResult.compiler,
      projectLocalResolveDir = foundConfigResult.projectLocalResolveDir,
      optionBasePaths = foundConfigResult.optionBasePaths;
  var projectLocalResolveHelper = (0, util_1.createProjectLocalResolveHelper)(projectLocalResolveDir);
  var ts = (0, configuration_1.loadCompiler)(compiler); // Experimental REPL await is not compatible targets lower than ES2018

  var targetSupportsTla = config.options.target >= ts.ScriptTarget.ES2018;

  if (options.experimentalReplAwait === true && !targetSupportsTla) {
    throw new Error('Experimental REPL await is not compatible with targets lower than ES2018');
  } // Top-level await was added in TS 3.8


  var tsVersionSupportsTla = (0, util_1.versionGteLt)(ts.version, '3.8.0');

  if (options.experimentalReplAwait === true && !tsVersionSupportsTla) {
    throw new Error('Experimental REPL await is not compatible with TypeScript versions older than 3.8');
  }

  var shouldReplAwait = options.experimentalReplAwait !== false && tsVersionSupportsTla && targetSupportsTla; // swc implies two other options
  // typeCheck option was implemented specifically to allow overriding tsconfig transpileOnly from the command-line
  // So we should allow using typeCheck to override swc

  if (options.swc && !options.typeCheck) {
    if (options.transpileOnly === false) {
      throw new Error("Cannot enable 'swc' option with 'transpileOnly: false'.  'swc' implies 'transpileOnly'.");
    }

    if (options.transpiler) {
      throw new Error("Cannot specify both 'swc' and 'transpiler' options.  'swc' uses the built-in swc transpiler.");
    }
  }

  var readFile = options.readFile || ts.sys.readFile;
  var fileExists = options.fileExists || ts.sys.fileExists; // typeCheck can override transpileOnly, useful for CLI flag to override config file

  var transpileOnly = (options.transpileOnly === true || options.swc === true) && options.typeCheck !== true;
  var transpiler = undefined;
  var transpilerBasePath = undefined;

  if (options.transpiler) {
    transpiler = options.transpiler;
    transpilerBasePath = optionBasePaths.transpiler;
  } else if (options.swc) {
    transpiler = require.resolve('./transpilers/swc.js');
    transpilerBasePath = optionBasePaths.swc;
  }

  var transformers = options.transformers || undefined;
  var diagnosticFilters = [{
    appliesToAllFiles: true,
    filenamesAbsolute: [],
    diagnosticsIgnored: [6059, 18002, 18003].concat(_toConsumableArray(options.experimentalTsImportSpecifiers ? [2691 // "An import path cannot end with a '.ts' extension. Consider importing '<specifier without ext>' instead."
    ] : []), _toConsumableArray(options.ignoreDiagnostics || [])).map(Number)
  }];
  var configDiagnosticList = filterDiagnostics(config.errors, diagnosticFilters);
  var outputCache = new Map();
  var configFileDirname = configFilePath ? (0, path_1.dirname)(configFilePath) : null;
  var scopeDir = (_c = (_b = (_a = options.scopeDir) !== null && _a !== void 0 ? _a : config.options.rootDir) !== null && _b !== void 0 ? _b : configFileDirname) !== null && _c !== void 0 ? _c : cwd;
  var ignoreBaseDir = configFileDirname !== null && configFileDirname !== void 0 ? configFileDirname : cwd;
  var isScoped = options.scope ? function (fileName) {
    return (0, path_1.relative)(scopeDir, fileName).charAt(0) !== '.';
  } : function () {
    return true;
  };
  var shouldIgnore = createIgnore(ignoreBaseDir, options.skipIgnore ? [] : (options.ignore || ['(?:^|/)node_modules/']).map(function (str) {
    return new RegExp(str);
  }));
  var diagnosticHost = {
    getNewLine: function getNewLine() {
      return ts.sys.newLine;
    },
    getCurrentDirectory: function getCurrentDirectory() {
      return cwd;
    },
    // TODO switch to getCanonicalFileName we already create later in scope
    getCanonicalFileName: ts.sys.useCaseSensitiveFileNames ? function (x) {
      return x;
    } : function (x) {
      return x.toLowerCase();
    }
  };

  if (options.transpileOnly && typeof transformers === 'function') {
    throw new TypeError('Transformers function is unavailable in "--transpile-only"');
  }

  var createTranspiler = initializeTranspilerFactory();

  function initializeTranspilerFactory() {
    var _a;

    if (transpiler) {
      var _createTranspiler = function _createTranspiler(compilerOptions, nodeModuleEmitKind) {
        return transpilerFactory === null || transpilerFactory === void 0 ? void 0 : transpilerFactory(_objectSpread({
          service: {
            options: options,
            config: _objectSpread({}, config, {
              options: compilerOptions
            }),
            projectLocalResolveHelper: projectLocalResolveHelper
          },
          transpilerConfigLocalResolveHelper: transpilerConfigLocalResolveHelper,
          nodeModuleEmitKind: nodeModuleEmitKind
        }, transpilerOptions));
      };

      if (!transpileOnly) throw new Error('Custom transpiler can only be used when transpileOnly is enabled.');
      var transpilerName = typeof transpiler === 'string' ? transpiler : transpiler[0];
      var transpilerOptions = typeof transpiler === 'string' ? {} : (_a = transpiler[1]) !== null && _a !== void 0 ? _a : {};
      var transpilerConfigLocalResolveHelper = transpilerBasePath ? (0, util_1.createProjectLocalResolveHelper)(transpilerBasePath) : projectLocalResolveHelper;
      var transpilerPath = transpilerConfigLocalResolveHelper(transpilerName, true);

      var transpilerFactory = require(transpilerPath).create;

      return _createTranspiler;
    }
  }
  /**
   * True if require() hooks should interop with experimental ESM loader.
   * Enabled explicitly via a flag since it is a breaking change.
   */


  var experimentalEsmLoader = false;

  function enableExperimentalEsmLoaderInterop() {
    experimentalEsmLoader = true;
  } // Install source map support and read from memory cache.


  installSourceMapSupport();

  function installSourceMapSupport() {
    var sourceMapSupport = require('@cspotcode/source-map-support');

    sourceMapSupport.install({
      environment: 'node',
      retrieveFile: function retrieveFile(pathOrUrl) {
        var _a;

        var path = pathOrUrl; // If it's a file URL, convert to local path
        // Note: fileURLToPath does not exist on early node v10
        // I could not find a way to handle non-URLs except to swallow an error

        if (experimentalEsmLoader && path.startsWith('file://')) {
          try {
            path = (0, url_1.fileURLToPath)(path);
          } catch (e) {
            /* swallow error */
          }
        }

        path = (0, util_1.normalizeSlashes)(path);
        return ((_a = outputCache.get(path)) === null || _a === void 0 ? void 0 : _a.content) || '';
      },
      redirectConflictingLibrary: true,
      onConflictingLibraryRedirect: function onConflictingLibraryRedirect(request, parent, isMain, options, redirectedRequest) {
        (0, exports.debug)("Redirected an attempt to require source-map-support to instead receive @cspotcode/source-map-support.  \"".concat(parent.filename, "\" attempted to require or resolve \"").concat(request, "\" and was redirected to \"").concat(redirectedRequest, "\"."));
      }
    });
  }

  var shouldHavePrettyErrors = options.pretty === undefined ? process.stdout.isTTY : options.pretty;
  var formatDiagnostics = shouldHavePrettyErrors ? ts.formatDiagnosticsWithColorAndContext || ts.formatDiagnostics : ts.formatDiagnostics;

  function createTSError(diagnostics) {
    var diagnosticText = formatDiagnostics(diagnostics, diagnosticHost);
    var diagnosticCodes = diagnostics.map(function (x) {
      return x.code;
    });
    return new TSError(diagnosticText, diagnosticCodes, diagnostics);
  }

  function reportTSError(configDiagnosticList) {
    var error = createTSError(configDiagnosticList);

    if (options.logError) {
      // Print error in red color and continue execution.
      console.error('\x1b[31m%s\x1b[0m', error);
    } else {
      // Throw error and exit the script.
      throw error;
    }
  } // Render the configuration errors.


  if (configDiagnosticList.length) reportTSError(configDiagnosticList);
  var jsxEmitPreserve = config.options.jsx === ts.JsxEmit.Preserve;
  /**
   * Get the extension for a transpiled file.
   * [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]
   */

  function getEmitExtension(path) {
    var lastDotIndex = path.lastIndexOf('.');

    if (lastDotIndex >= 0) {
      var ext = path.slice(lastDotIndex);

      switch (ext) {
        case '.js':
        case '.ts':
          return '.js';

        case '.jsx':
        case '.tsx':
          return jsxEmitPreserve ? '.jsx' : '.js';

        case '.mjs':
        case '.mts':
          return '.mjs';

        case '.cjs':
        case '.cts':
          return '.cjs';
      }
    }

    return '.js';
  }
  /**
   * Get output from TS compiler w/typechecking.  `undefined` in `transpileOnly`
   * mode.
   */


  var getOutput;
  var getTypeInfo;
  var getCanonicalFileName = ts.createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames);
  var moduleTypeClassifier = (0, module_type_classifier_1.createModuleTypeClassifier)({
    basePath: (_d = options.optionBasePaths) === null || _d === void 0 ? void 0 : _d.moduleTypes,
    patterns: options.moduleTypes
  });
  var extensions = (0, file_extensions_1.getExtensions)(config, options, ts.version); // Use full language services when the fast option is disabled.

  if (!transpileOnly) {
    var fileContents = new Map();
    var rootFileNames = new Set(config.fileNames);
    var cachedReadFile = (0, util_1.cachedLookup)(debugFn('readFile', readFile)); // Use language services by default

    if (!options.compilerHost) {
      var projectVersion = 1;
      var fileVersions = new Map(Array.from(rootFileNames).map(function (fileName) {
        return [fileName, 0];
      }));

      var getCustomTransformers = function getCustomTransformers() {
        if (typeof transformers === 'function') {
          var program = service.getProgram();
          return program ? transformers(program) : undefined;
        }

        return transformers;
      }; // Create the compiler host for type checking.


      var serviceHost = {
        getProjectVersion: function getProjectVersion() {
          return String(projectVersion);
        },
        getScriptFileNames: function getScriptFileNames() {
          return Array.from(rootFileNames);
        },
        getScriptVersion: function getScriptVersion(fileName) {
          var version = fileVersions.get(fileName);
          return version ? version.toString() : '';
        },
        getScriptSnapshot: function getScriptSnapshot(fileName) {
          // TODO ordering of this with getScriptVersion?  Should they sync up?
          var contents = fileContents.get(fileName); // Read contents into TypeScript memory cache.

          if (contents === undefined) {
            contents = cachedReadFile(fileName);
            if (contents === undefined) return;
            fileVersions.set(fileName, 1);
            fileContents.set(fileName, contents);
            projectVersion++;
          }

          return ts.ScriptSnapshot.fromString(contents);
        },
        readFile: cachedReadFile,
        readDirectory: ts.sys.readDirectory,
        getDirectories: (0, util_1.cachedLookup)(debugFn('getDirectories', ts.sys.getDirectories)),
        fileExists: (0, util_1.cachedLookup)(debugFn('fileExists', fileExists)),
        directoryExists: (0, util_1.cachedLookup)(debugFn('directoryExists', ts.sys.directoryExists)),
        realpath: ts.sys.realpath ? (0, util_1.cachedLookup)(debugFn('realpath', ts.sys.realpath)) : undefined,
        getNewLine: function getNewLine() {
          return ts.sys.newLine;
        },
        useCaseSensitiveFileNames: function useCaseSensitiveFileNames() {
          return ts.sys.useCaseSensitiveFileNames;
        },
        getCurrentDirectory: function getCurrentDirectory() {
          return cwd;
        },
        getCompilationSettings: function getCompilationSettings() {
          return config.options;
        },
        getDefaultLibFileName: function getDefaultLibFileName() {
          return ts.getDefaultLibFilePath(config.options);
        },
        getCustomTransformers: getCustomTransformers,
        trace: options.tsTrace
      };

      var _ref = (0, resolver_functions_1.createResolverFunctions)({
        host: serviceHost,
        getCanonicalFileName: getCanonicalFileName,
        ts: ts,
        cwd: cwd,
        config: config,
        projectLocalResolveHelper: projectLocalResolveHelper,
        options: options,
        extensions: extensions
      }),
          resolveModuleNames = _ref.resolveModuleNames,
          getResolvedModuleWithFailedLookupLocationsFromCache = _ref.getResolvedModuleWithFailedLookupLocationsFromCache,
          resolveTypeReferenceDirectives = _ref.resolveTypeReferenceDirectives,
          isFileKnownToBeInternal = _ref.isFileKnownToBeInternal,
          markBucketOfFilenameInternal = _ref.markBucketOfFilenameInternal;

      serviceHost.resolveModuleNames = resolveModuleNames;
      serviceHost.getResolvedModuleWithFailedLookupLocationsFromCache = getResolvedModuleWithFailedLookupLocationsFromCache;
      serviceHost.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives;
      var registry = ts.createDocumentRegistry(ts.sys.useCaseSensitiveFileNames, cwd);
      var service = ts.createLanguageService(serviceHost, registry);

      var updateMemoryCache = function updateMemoryCache(contents, fileName) {
        // Add to `rootFiles` as necessary, either to make TS include a file it has not seen,
        // or to trigger a re-classification of files from external to internal.
        if (!rootFileNames.has(fileName) && !isFileKnownToBeInternal(fileName)) {
          markBucketOfFilenameInternal(fileName);
          rootFileNames.add(fileName); // Increment project version for every change to rootFileNames.

          projectVersion++;
        }

        var previousVersion = fileVersions.get(fileName) || 0;
        var previousContents = fileContents.get(fileName); // Avoid incrementing cache when nothing has changed.

        if (contents !== previousContents) {
          fileVersions.set(fileName, previousVersion + 1);
          fileContents.set(fileName, contents); // Increment project version for every file change.

          projectVersion++;
        }
      };

      var previousProgram = undefined;

      getOutput = function getOutput(code, fileName) {
        updateMemoryCache(code, fileName);
        var programBefore = service.getProgram();

        if (programBefore !== previousProgram) {
          (0, exports.debug)("compiler rebuilt Program instance when getting output for ".concat(fileName));
        }

        var output = service.getEmitOutput(fileName); // Get the relevant diagnostics - this is 3x faster than `getPreEmitDiagnostics`.

        var diagnostics = service.getSemanticDiagnostics(fileName).concat(service.getSyntacticDiagnostics(fileName));
        var programAfter = service.getProgram();
        (0, exports.debug)('invariant: Is service.getProject() identical before and after getting emit output and diagnostics? (should always be true) ', programBefore === programAfter);
        previousProgram = programAfter;
        var diagnosticList = filterDiagnostics(diagnostics, diagnosticFilters);
        if (diagnosticList.length) reportTSError(diagnosticList);

        if (output.emitSkipped) {
          return [undefined, undefined, true];
        } // Throw an error when requiring `.d.ts` files.


        if (output.outputFiles.length === 0) {
          throw new TypeError("Unable to require file: ".concat((0, path_1.relative)(cwd, fileName), "\n") + 'This is usually the result of a faulty configuration or import. ' + 'Make sure there is a `.js`, `.json` or other executable extension with ' + 'loader attached before `ts-node` available.');
        }

        return [output.outputFiles[1].text, output.outputFiles[0].text, false];
      };

      getTypeInfo = function getTypeInfo(code, fileName, position) {
        var normalizedFileName = (0, util_1.normalizeSlashes)(fileName);
        updateMemoryCache(code, normalizedFileName);
        var info = service.getQuickInfoAtPosition(normalizedFileName, position);
        var name = ts.displayPartsToString(info ? info.displayParts : []);
        var comment = ts.displayPartsToString(info ? info.documentation : []);
        return {
          name: name,
          comment: comment
        };
      };
    } else {
      var sys = _objectSpread({}, ts.sys, {}, diagnosticHost, {
        readFile: function readFile(fileName) {
          var cacheContents = fileContents.get(fileName);
          if (cacheContents !== undefined) return cacheContents;
          var contents = cachedReadFile(fileName);
          if (contents) fileContents.set(fileName, contents);
          return contents;
        },
        readDirectory: ts.sys.readDirectory,
        getDirectories: (0, util_1.cachedLookup)(debugFn('getDirectories', ts.sys.getDirectories)),
        fileExists: (0, util_1.cachedLookup)(debugFn('fileExists', fileExists)),
        directoryExists: (0, util_1.cachedLookup)(debugFn('directoryExists', ts.sys.directoryExists)),
        resolvePath: (0, util_1.cachedLookup)(debugFn('resolvePath', ts.sys.resolvePath)),
        realpath: ts.sys.realpath ? (0, util_1.cachedLookup)(debugFn('realpath', ts.sys.realpath)) : undefined
      });

      var host = ts.createIncrementalCompilerHost ? ts.createIncrementalCompilerHost(config.options, sys) : _objectSpread({}, sys, {
        getSourceFile: function getSourceFile(fileName, languageVersion) {
          var contents = sys.readFile(fileName);
          if (contents === undefined) return;
          return ts.createSourceFile(fileName, contents, languageVersion);
        },
        getDefaultLibLocation: function getDefaultLibLocation() {
          return (0, util_1.normalizeSlashes)((0, path_1.dirname)(compiler));
        },
        getDefaultLibFileName: function getDefaultLibFileName() {
          return (0, util_1.normalizeSlashes)((0, path_1.join)((0, path_1.dirname)(compiler), ts.getDefaultLibFileName(config.options)));
        },
        useCaseSensitiveFileNames: function useCaseSensitiveFileNames() {
          return sys.useCaseSensitiveFileNames;
        }
      });
      host.trace = options.tsTrace;

      var _ref2 = (0, resolver_functions_1.createResolverFunctions)({
        host: host,
        cwd: cwd,
        config: config,
        ts: ts,
        getCanonicalFileName: getCanonicalFileName,
        projectLocalResolveHelper: projectLocalResolveHelper,
        options: options,
        extensions: extensions
      }),
          _resolveModuleNames = _ref2.resolveModuleNames,
          _resolveTypeReferenceDirectives = _ref2.resolveTypeReferenceDirectives,
          _isFileKnownToBeInternal = _ref2.isFileKnownToBeInternal,
          _markBucketOfFilenameInternal = _ref2.markBucketOfFilenameInternal;

      host.resolveModuleNames = _resolveModuleNames;
      host.resolveTypeReferenceDirectives = _resolveTypeReferenceDirectives; // Fallback for older TypeScript releases without incremental API.

      var builderProgram = ts.createIncrementalProgram ? ts.createIncrementalProgram({
        rootNames: Array.from(rootFileNames),
        options: config.options,
        host: host,
        configFileParsingDiagnostics: config.errors,
        projectReferences: config.projectReferences
      }) : ts.createEmitAndSemanticDiagnosticsBuilderProgram(Array.from(rootFileNames), config.options, host, undefined, config.errors, config.projectReferences); // Read and cache custom transformers.

      var customTransformers = typeof transformers === 'function' ? transformers(builderProgram.getProgram()) : transformers; // Set the file contents into cache manually.

      var _updateMemoryCache = function _updateMemoryCache(contents, fileName) {
        var previousContents = fileContents.get(fileName);
        var contentsChanged = previousContents !== contents;

        if (contentsChanged) {
          fileContents.set(fileName, contents);
        } // Add to `rootFiles` when discovered by compiler for the first time.


        var addedToRootFileNames = false;

        if (!rootFileNames.has(fileName) && !_isFileKnownToBeInternal(fileName)) {
          _markBucketOfFilenameInternal(fileName);

          rootFileNames.add(fileName);
          addedToRootFileNames = true;
        } // Update program when file changes.


        if (addedToRootFileNames || contentsChanged) {
          builderProgram = ts.createEmitAndSemanticDiagnosticsBuilderProgram(Array.from(rootFileNames), config.options, host, builderProgram, config.errors, config.projectReferences);
        }
      };

      getOutput = function getOutput(code, fileName) {
        var outText = '';
        var outMap = '';

        _updateMemoryCache(code, fileName);

        var sourceFile = builderProgram.getSourceFile(fileName);
        if (!sourceFile) throw new TypeError("Unable to read file: ".concat(fileName));
        var program = builderProgram.getProgram();
        var diagnostics = ts.getPreEmitDiagnostics(program, sourceFile);
        var diagnosticList = filterDiagnostics(diagnostics, diagnosticFilters);
        if (diagnosticList.length) reportTSError(diagnosticList);
        var result = builderProgram.emit(sourceFile, function (path, file, writeByteOrderMark) {
          if (path.endsWith('.map')) {
            outMap = file;
          } else {
            outText = file;
          }

          if (options.emit) sys.writeFile(path, file, writeByteOrderMark);
        }, undefined, undefined, customTransformers);

        if (result.emitSkipped) {
          return [undefined, undefined, true];
        } // Throw an error when requiring files that cannot be compiled.


        if (outText === '') {
          if (program.isSourceFileFromExternalLibrary(sourceFile)) {
            throw new TypeError("Unable to compile file from external library: ".concat((0, path_1.relative)(cwd, fileName)));
          }

          throw new TypeError("Unable to require file: ".concat((0, path_1.relative)(cwd, fileName), "\n") + 'This is usually the result of a faulty configuration or import. ' + 'Make sure there is a `.js`, `.json` or other executable extension with ' + 'loader attached before `ts-node` available.');
        }

        return [outText, outMap, false];
      };

      getTypeInfo = function getTypeInfo(code, fileName, position) {
        var normalizedFileName = (0, util_1.normalizeSlashes)(fileName);

        _updateMemoryCache(code, normalizedFileName);

        var sourceFile = builderProgram.getSourceFile(normalizedFileName);
        if (!sourceFile) throw new TypeError("Unable to read file: ".concat(fileName));
        var node = getTokenAtPosition(ts, sourceFile, position);
        var checker = builderProgram.getProgram().getTypeChecker();
        var symbol = checker.getSymbolAtLocation(node);
        if (!symbol) return {
          name: '',
          comment: ''
        };
        var type = checker.getTypeOfSymbolAtLocation(symbol, node);
        var signatures = [].concat(_toConsumableArray(type.getConstructSignatures()), _toConsumableArray(type.getCallSignatures()));
        return {
          name: signatures.length ? signatures.map(function (x) {
            return checker.signatureToString(x);
          }).join('\n') : checker.typeToString(type),
          comment: ts.displayPartsToString(symbol ? symbol.getDocumentationComment(checker) : [])
        };
      }; // Write `.tsbuildinfo` when `--build` is enabled.


      if (options.emit && config.options.incremental) {
        process.on('exit', function () {
          // Emits `.tsbuildinfo` to filesystem.
          builderProgram.getProgram().emitBuildInfo();
        });
      }
    }
  } else {
    getTypeInfo = function getTypeInfo() {
      throw new TypeError('Type information is unavailable in "--transpile-only"');
    };
  }

  function createTranspileOnlyGetOutputFunction(overrideModuleType, nodeModuleEmitKind) {
    var compilerOptions = _objectSpread({}, config.options);

    if (overrideModuleType !== undefined) compilerOptions.module = overrideModuleType;
    var customTranspiler = createTranspiler === null || createTranspiler === void 0 ? void 0 : createTranspiler(compilerOptions, nodeModuleEmitKind);
    var tsTranspileModule = (0, util_1.versionGteLt)(ts.version, '4.7.0') ? (0, ts_transpile_module_1.createTsTranspileModule)(ts, {
      compilerOptions: compilerOptions,
      reportDiagnostics: true,
      transformers: transformers
    }) : undefined;
    return function (code, fileName) {
      var result;

      if (customTranspiler) {
        result = customTranspiler.transpile(code, {
          fileName: fileName
        });
      } else if (tsTranspileModule) {
        result = tsTranspileModule(code, {
          fileName: fileName
        }, nodeModuleEmitKind === 'nodeesm' ? 'module' : 'commonjs');
      } else {
        result = ts.transpileModule(code, {
          fileName: fileName,
          compilerOptions: compilerOptions,
          reportDiagnostics: true,
          transformers: transformers
        });
      }

      var diagnosticList = filterDiagnostics(result.diagnostics || [], diagnosticFilters);
      if (diagnosticList.length) reportTSError(diagnosticList);
      return [result.outputText, result.sourceMapText, false];
    };
  } // When true, these mean that a `moduleType` override will cause a different emit
  // than the TypeScript compiler, so we *must* overwrite the emit.


  var shouldOverwriteEmitWhenForcingCommonJS = config.options.module !== ts.ModuleKind.CommonJS; // [MUST_UPDATE_FOR_NEW_MODULEKIND]

  var shouldOverwriteEmitWhenForcingEsm = !(config.options.module === ts.ModuleKind.ES2015 || ts.ModuleKind.ES2020 && config.options.module === ts.ModuleKind.ES2020 || ts.ModuleKind.ES2022 && config.options.module === ts.ModuleKind.ES2022 || config.options.module === ts.ModuleKind.ESNext);
  /**
   * node16 or nodenext
   * [MUST_UPDATE_FOR_NEW_MODULEKIND]
   */

  var isNodeModuleType = ts.ModuleKind.Node16 && config.options.module === ts.ModuleKind.Node16 || ts.ModuleKind.NodeNext && config.options.module === ts.ModuleKind.NodeNext;
  var getOutputForceCommonJS = createTranspileOnlyGetOutputFunction(ts.ModuleKind.CommonJS);
  var getOutputForceNodeCommonJS = createTranspileOnlyGetOutputFunction(ts.ModuleKind.NodeNext, 'nodecjs');
  var getOutputForceNodeESM = createTranspileOnlyGetOutputFunction(ts.ModuleKind.NodeNext, 'nodeesm'); // [MUST_UPDATE_FOR_NEW_MODULEKIND]

  var getOutputForceESM = createTranspileOnlyGetOutputFunction(ts.ModuleKind.ES2022 || ts.ModuleKind.ES2020 || ts.ModuleKind.ES2015);
  var getOutputTranspileOnly = createTranspileOnlyGetOutputFunction(); // Create a simple TypeScript compiler proxy.

  function compile(code, fileName) {
    var lineOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var normalizedFileName = (0, util_1.normalizeSlashes)(fileName);
    var classification = moduleTypeClassifier.classifyModuleByModuleTypeOverrides(normalizedFileName);
    var value = '';
    var sourceMap = '';
    var emitSkipped = true;

    if (getOutput) {
      // Must always call normal getOutput to throw typechecking errors
      var _getOutput = getOutput(code, normalizedFileName);

      var _getOutput2 = _slicedToArray(_getOutput, 3);

      value = _getOutput2[0];
      sourceMap = _getOutput2[1];
      emitSkipped = _getOutput2[2];
    } // If module classification contradicts the above, call the relevant transpiler


    if (classification.moduleType === 'cjs' && (shouldOverwriteEmitWhenForcingCommonJS || emitSkipped)) {
      var _getOutputForceCommon = getOutputForceCommonJS(code, normalizedFileName);

      var _getOutputForceCommon2 = _slicedToArray(_getOutputForceCommon, 2);

      value = _getOutputForceCommon2[0];
      sourceMap = _getOutputForceCommon2[1];
    } else if (classification.moduleType === 'esm' && (shouldOverwriteEmitWhenForcingEsm || emitSkipped)) {
      var _getOutputForceESM = getOutputForceESM(code, normalizedFileName);

      var _getOutputForceESM2 = _slicedToArray(_getOutputForceESM, 2);

      value = _getOutputForceESM2[0];
      sourceMap = _getOutputForceESM2[1];
    } else if (emitSkipped) {
      // Happens when ts compiler skips emit or in transpileOnly mode
      var _classification = (0, node_module_type_classifier_1.classifyModule)(fileName, isNodeModuleType);

      var _ref3 = _classification === 'nodecjs' ? getOutputForceNodeCommonJS(code, normalizedFileName) : _classification === 'nodeesm' ? getOutputForceNodeESM(code, normalizedFileName) : _classification === 'cjs' ? getOutputForceCommonJS(code, normalizedFileName) : _classification === 'esm' ? getOutputForceESM(code, normalizedFileName) : getOutputTranspileOnly(code, normalizedFileName);

      var _ref4 = _slicedToArray(_ref3, 2);

      value = _ref4[0];
      sourceMap = _ref4[1];
    }

    var output = updateOutput(value, normalizedFileName, sourceMap, getEmitExtension);
    outputCache.set(normalizedFileName, {
      content: output
    });
    return output;
  }

  var active = true;

  var enabled = function enabled(_enabled) {
    return _enabled === undefined ? active : active = !!_enabled;
  };

  var ignored = function ignored(fileName) {
    if (!active) return true;
    var ext = (0, path_1.extname)(fileName);

    if (extensions.compiled.includes(ext)) {
      return !isScoped(fileName) || shouldIgnore(fileName);
    }

    return true;
  };

  function addDiagnosticFilter(filter) {
    diagnosticFilters.push(_objectSpread({}, filter, {
      filenamesAbsolute: filter.filenamesAbsolute.map(function (f) {
        return (0, util_1.normalizeSlashes)(f);
      })
    }));
  }

  var getNodeEsmResolver = (0, util_1.once)(function () {
    return require('../dist-raw/node-internal-modules-esm-resolve').createResolve({
      extensions: extensions,
      preferTsExts: options.preferTsExts,
      tsNodeExperimentalSpecifierResolution: options.experimentalSpecifierResolution
    });
  });
  var getNodeEsmGetFormat = (0, util_1.once)(function () {
    return require('../dist-raw/node-internal-modules-esm-get_format').createGetFormat(options.experimentalSpecifierResolution, getNodeEsmResolver());
  });
  var getNodeCjsLoader = (0, util_1.once)(function () {
    return require('../dist-raw/node-internal-modules-cjs-loader').createCjsLoader({
      extensions: extensions,
      preferTsExts: options.preferTsExts,
      nodeEsmResolver: getNodeEsmResolver()
    });
  });
  return _ref5 = {}, _defineProperty(_ref5, TS_NODE_SERVICE_BRAND, true), _defineProperty(_ref5, "ts", ts), _defineProperty(_ref5, "compilerPath", compiler), _defineProperty(_ref5, "config", config), _defineProperty(_ref5, "compile", compile), _defineProperty(_ref5, "getTypeInfo", getTypeInfo), _defineProperty(_ref5, "ignored", ignored), _defineProperty(_ref5, "enabled", enabled), _defineProperty(_ref5, "options", options), _defineProperty(_ref5, "configFilePath", configFilePath), _defineProperty(_ref5, "moduleTypeClassifier", moduleTypeClassifier), _defineProperty(_ref5, "shouldReplAwait", shouldReplAwait), _defineProperty(_ref5, "addDiagnosticFilter", addDiagnosticFilter), _defineProperty(_ref5, "installSourceMapSupport", installSourceMapSupport), _defineProperty(_ref5, "enableExperimentalEsmLoaderInterop", enableExperimentalEsmLoaderInterop), _defineProperty(_ref5, "transpileOnly", transpileOnly), _defineProperty(_ref5, "projectLocalResolveHelper", projectLocalResolveHelper), _defineProperty(_ref5, "getNodeEsmResolver", getNodeEsmResolver), _defineProperty(_ref5, "getNodeEsmGetFormat", getNodeEsmGetFormat), _defineProperty(_ref5, "getNodeCjsLoader", getNodeCjsLoader), _defineProperty(_ref5, "extensions", extensions), _ref5;
}

exports.createFromPreloadedConfig = createFromPreloadedConfig;
/**
 * Check if the filename should be ignored.
 */

function createIgnore(ignoreBaseDir, ignore) {
  return function (fileName) {
    var relname = (0, path_1.relative)(ignoreBaseDir, fileName);
    var path = (0, util_1.normalizeSlashes)(relname);
    return ignore.some(function (x) {
      return x.test(path);
    });
  };
}
/**
 * Register the extensions to support when importing files.
 */


function registerExtensions(preferTsExts, extensions, service, originalJsHandler) {
  var exts = new Set(extensions); // Can't add these extensions cuz would allow omitting file extension; node requires ext for .cjs and .mjs
  // Unless they're already registered by something else (nyc does this):
  // then we *must* hook them or else our transformer will not be called.

  for (var _i2 = 0, _arr2 = ['.mts', '.cts', '.mjs', '.cjs']; _i2 < _arr2.length; _i2++) {
    var cannotAdd = _arr2[_i2];

    if (exts.has(cannotAdd) && !(0, util_1.hasOwnProperty)(require.extensions, cannotAdd)) {
      // Unrecognized file exts can be transformed via the `.js` handler.
      exts.add('.js');
      exts["delete"](cannotAdd);
    }
  } // Register new extensions.


  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = exts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _ext = _step.value;
      registerExtension(_ext, service, originalJsHandler);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (preferTsExts) {
    var preferredExtensions = new Set([].concat(_toConsumableArray(exts), _toConsumableArray(Object.keys(require.extensions)))); // Re-sort iteration order of Object.keys()

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = preferredExtensions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var ext = _step2.value;
        var old = Object.getOwnPropertyDescriptor(require.extensions, ext);
        delete require.extensions[ext];
        Object.defineProperty(require.extensions, ext, old);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }
}
/**
 * Register the extension for node.
 */


function registerExtension(ext, service, originalHandler) {
  var old = require.extensions[ext] || originalHandler;

  require.extensions[ext] = function (m, filename) {
    if (service.ignored(filename)) return old(m, filename);
    assertScriptCanLoadAsCJS(service, m, filename);
    var _compile = m._compile;

    m._compile = function (code, fileName) {
      (0, exports.debug)('module._compile', fileName);
      var result = service.compile(code, fileName);
      return _compile.call(this, result, fileName);
    };

    return old(m, filename);
  };
}
/**
 * Update the output remapping the source map.
 */


function updateOutput(outputText, fileName, sourceMap, getEmitExtension) {
  var base64Map = Buffer.from(updateSourceMap(sourceMap, fileName), 'utf8').toString('base64');
  var sourceMapContent = "//# sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64Map); // Expected form: `//# sourceMappingURL=foo bar.js.map` or `//# sourceMappingURL=foo%20bar.js.map` for input file "foo bar.tsx"
  // Percent-encoding behavior added in TS 4.1.1: https://github.com/microsoft/TypeScript/issues/40951

  var prefix = '//# sourceMappingURL=';
  var prefixLength = prefix.length;
  var baseName =
  /*foo.tsx*/
  (0, path_1.basename)(fileName);
  var extName =
  /*.tsx*/
  (0, path_1.extname)(fileName);
  var extension =
  /*.js*/
  getEmitExtension(fileName);
  var sourcemapFilename = baseName.slice(0, -extName.length) + extension + '.map';
  var sourceMapLengthWithoutPercentEncoding = prefixLength + sourcemapFilename.length;
  /*
   * Only rewrite if existing directive exists at the location we expect, to support:
   *   a) compilers that do not append a sourcemap directive
   *   b) situations where we did the math wrong
   *     Not ideal, but appending our sourcemap *after* a pre-existing sourcemap still overrides, so the end-user is happy.
   */

  if (outputText.substr(-sourceMapLengthWithoutPercentEncoding, prefixLength) === prefix) {
    return outputText.slice(0, -sourceMapLengthWithoutPercentEncoding) + sourceMapContent;
  } // If anyone asks why we're not using URL, the URL equivalent is: `u = new URL('http://d'); u.pathname = "/" + sourcemapFilename; return u.pathname.slice(1);


  var sourceMapLengthWithPercentEncoding = prefixLength + encodeURI(sourcemapFilename).length;

  if (outputText.substr(-sourceMapLengthWithPercentEncoding, prefixLength) === prefix) {
    return outputText.slice(0, -sourceMapLengthWithPercentEncoding) + sourceMapContent;
  }

  return "".concat(outputText, "\n").concat(sourceMapContent);
}
/**
 * Update the source map contents for improved output.
 */


function updateSourceMap(sourceMapText, fileName) {
  var sourceMap = JSON.parse(sourceMapText);
  sourceMap.file = fileName;
  sourceMap.sources = [fileName];
  delete sourceMap.sourceRoot;
  return JSON.stringify(sourceMap);
}
/**
 * Filter diagnostics.
 */


function filterDiagnostics(diagnostics, filters) {
  return diagnostics.filter(function (d) {
    return filters.every(function (f) {
      var _a;

      return !f.appliesToAllFiles && f.filenamesAbsolute.indexOf((_a = d.file) === null || _a === void 0 ? void 0 : _a.fileName) === -1 || f.diagnosticsIgnored.indexOf(d.code) === -1;
    });
  });
}
/**
 * Get token at file position.
 *
 * Reference: https://github.com/microsoft/TypeScript/blob/fcd9334f57d85b73dd66ad2d21c02e84822f4841/src/services/utilities.ts#L705-L731
 */


function getTokenAtPosition(ts, sourceFile, position) {
  var current = sourceFile;

  outer: while (true) {
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = current.getChildren(sourceFile)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var child = _step3.value;
        var start = child.getFullStart();
        if (start > position) break;
        var end = child.getEnd();

        if (position <= end) {
          current = child;
          continue outer;
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    return current;
  }
}
/**
 * Create an implementation of node's ESM loader hooks.
 *
 * This may be useful if you
 * want to wrap or compose the loader hooks to add additional functionality or
 * combine with another loader.
 *
 * Node changed the hooks API, so there are two possible APIs.  This function
 * detects your node version and returns the appropriate API.
 *
 * @category ESM Loader
 */


var createEsmHooks = function createEsmHooks(tsNodeService) {
  return require('./esm').createEsmHooks(tsNodeService);
};

exports.createEsmHooks = createEsmHooks;