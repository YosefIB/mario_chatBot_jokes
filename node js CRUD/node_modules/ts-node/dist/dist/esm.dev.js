"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createEsmHooks = exports.registerAndCreateEsmHooks = exports.filterHooksByAPIVersion = void 0;

var index_1 = require("./index");

var url_1 = require("url");

var path_1 = require("path");

var assert = require("assert");

var util_1 = require("./util");

var module_1 = require("module"); // The hooks API changed in node version X so we need to check for backwards compatibility.


var newHooksAPI = (0, util_1.versionGteLt)(process.versions.node, '16.12.0');
/** @internal */

function filterHooksByAPIVersion(hooks) {
  var getFormat = hooks.getFormat,
      load = hooks.load,
      resolve = hooks.resolve,
      transformSource = hooks.transformSource; // Explicit return type to avoid TS's non-ideal inferred type

  var hooksAPI = newHooksAPI ? {
    resolve: resolve,
    load: load,
    getFormat: undefined,
    transformSource: undefined
  } : {
    resolve: resolve,
    getFormat: getFormat,
    transformSource: transformSource,
    load: undefined
  };
  return hooksAPI;
}

exports.filterHooksByAPIVersion = filterHooksByAPIVersion;
/** @internal */

function registerAndCreateEsmHooks(opts) {
  // Automatically performs registration just like `-r ts-node/register`
  var tsNodeInstance = (0, index_1.register)(opts);
  return createEsmHooks(tsNodeInstance);
}

exports.registerAndCreateEsmHooks = registerAndCreateEsmHooks;

function createEsmHooks(tsNodeService) {
  tsNodeService.enableExperimentalEsmLoaderInterop(); // Custom implementation that considers additional file extensions and automatically adds file extensions

  var nodeResolveImplementation = tsNodeService.getNodeEsmResolver();
  var nodeGetFormatImplementation = tsNodeService.getNodeEsmGetFormat();
  var extensions = tsNodeService.extensions;
  var hooksAPI = filterHooksByAPIVersion({
    resolve: resolve,
    load: load,
    getFormat: getFormat,
    transformSource: transformSource
  });

  function isFileUrlOrNodeStyleSpecifier(parsed) {
    // We only understand file:// URLs, but in node, the specifier can be a node-style `./foo` or `foo`
    var protocol = parsed.protocol;
    return protocol === null || protocol === 'file:';
  }
  /**
   * Named "probably" as a reminder that this is a guess.
   * node does not explicitly tell us if we're resolving the entrypoint or not.
   */


  function isProbablyEntrypoint(specifier, parentURL) {
    return parentURL === undefined && specifier.startsWith('file://');
  } // Side-channel between `resolve()` and `load()` hooks


  var rememberIsProbablyEntrypoint = new Set();
  var rememberResolvedViaCommonjsFallback = new Set();

  function resolve(specifier, context, defaultResolve) {
    var defer, entrypointFallback;
    return regeneratorRuntime.async(function resolve$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            entrypointFallback = function _ref(cb) {
              var resolution, cjsSpecifier, _resolution;

              return regeneratorRuntime.async(function entrypointFallback$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      _context3.prev = 0;
                      _context3.next = 3;
                      return regeneratorRuntime.awrap(cb());

                    case 3:
                      resolution = _context3.sent;
                      if ((resolution === null || resolution === void 0 ? void 0 : resolution.url) && isProbablyEntrypoint(specifier, context.parentURL)) rememberIsProbablyEntrypoint.add(resolution.url);
                      return _context3.abrupt("return", resolution);

                    case 8:
                      _context3.prev = 8;
                      _context3.t0 = _context3["catch"](0);

                      if (isProbablyEntrypoint(specifier, context.parentURL)) {
                        _context3.next = 12;
                        break;
                      }

                      throw _context3.t0;

                    case 12:
                      _context3.prev = 12;
                      cjsSpecifier = specifier; // Attempt to convert from ESM file:// to CommonJS path

                      try {
                        if (specifier.startsWith('file://')) cjsSpecifier = (0, url_1.fileURLToPath)(specifier);
                      } catch (_unused) {}

                      _resolution = (0, url_1.pathToFileURL)((0, module_1.createRequire)(process.cwd()).resolve(cjsSpecifier)).toString();
                      rememberIsProbablyEntrypoint.add(_resolution);
                      rememberResolvedViaCommonjsFallback.add(_resolution);
                      return _context3.abrupt("return", {
                        url: _resolution,
                        format: 'commonjs'
                      });

                    case 21:
                      _context3.prev = 21;
                      _context3.t1 = _context3["catch"](12);
                      throw _context3.t0;

                    case 24:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, null, null, [[0, 8], [12, 21]]);
            };

            defer = function defer() {
              var r;
              return regeneratorRuntime.async(function defer$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.next = 2;
                      return regeneratorRuntime.awrap(defaultResolve(specifier, context, defaultResolve));

                    case 2:
                      r = _context2.sent;
                      return _context2.abrupt("return", r);

                    case 4:
                    case "end":
                      return _context2.stop();
                  }
                }
              });
            }; // See: https://github.com/nodejs/node/discussions/41711
            // nodejs will likely implement a similar fallback.  Till then, we can do our users a favor and fallback today.


            return _context5.abrupt("return", addShortCircuitFlag(function _callee() {
              var parsed, pathname, protocol, hostname;
              return regeneratorRuntime.async(function _callee$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      parsed = (0, url_1.parse)(specifier);
                      pathname = parsed.pathname, protocol = parsed.protocol, hostname = parsed.hostname;

                      if (isFileUrlOrNodeStyleSpecifier(parsed)) {
                        _context4.next = 4;
                        break;
                      }

                      return _context4.abrupt("return", entrypointFallback(defer));

                    case 4:
                      if (!(protocol !== null && protocol !== 'file:')) {
                        _context4.next = 6;
                        break;
                      }

                      return _context4.abrupt("return", entrypointFallback(defer));

                    case 6:
                      if (!hostname) {
                        _context4.next = 8;
                        break;
                      }

                      return _context4.abrupt("return", entrypointFallback(defer));

                    case 8:
                      return _context4.abrupt("return", entrypointFallback(function () {
                        return nodeResolveImplementation.defaultResolve(specifier, context, defaultResolve);
                      }));

                    case 9:
                    case "end":
                      return _context4.stop();
                  }
                }
              });
            }));

          case 3:
          case "end":
            return _context5.stop();
        }
      }
    });
  } // `load` from new loader hook API (See description at the top of this file)


  function load(url, context, defaultLoad) {
    return regeneratorRuntime.async(function load$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            return _context8.abrupt("return", addShortCircuitFlag(function _callee2() {
              var _a, format, source, _ref2, rawSource, defaultTransformSource, _ref3, transformedSource;

              return regeneratorRuntime.async(function _callee2$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      if (!((_a = context.format) !== null && _a !== void 0)) {
                        _context7.next = 4;
                        break;
                      }

                      _context7.t0 = _a;
                      _context7.next = 7;
                      break;

                    case 4:
                      _context7.next = 6;
                      return regeneratorRuntime.awrap(getFormat(url, context, nodeGetFormatImplementation.defaultGetFormat));

                    case 6:
                      _context7.t0 = _context7.sent.format;

                    case 7:
                      format = _context7.t0;
                      source = undefined;

                      if (!(format !== 'builtin' && format !== 'commonjs')) {
                        _context7.next = 22;
                        break;
                      }

                      _context7.next = 12;
                      return regeneratorRuntime.awrap(defaultLoad(url, _objectSpread({}, context, {
                        format: format
                      }), defaultLoad));

                    case 12:
                      _ref2 = _context7.sent;
                      rawSource = _ref2.source;

                      if (!(rawSource === undefined || rawSource === null)) {
                        _context7.next = 16;
                        break;
                      }

                      throw new Error("Failed to load raw source: Format was '".concat(format, "' and url was '").concat(url, "''."));

                    case 16:
                      // Emulate node's built-in old defaultTransformSource() so we can re-use the old transformSource() hook
                      defaultTransformSource = function defaultTransformSource(source, _context, _defaultTransformSource) {
                        return regeneratorRuntime.async(function defaultTransformSource$(_context6) {
                          while (1) {
                            switch (_context6.prev = _context6.next) {
                              case 0:
                                return _context6.abrupt("return", {
                                  source: source
                                });

                              case 1:
                              case "end":
                                return _context6.stop();
                            }
                          }
                        });
                      }; // Call the old hook


                      _context7.next = 19;
                      return regeneratorRuntime.awrap(transformSource(rawSource, {
                        url: url,
                        format: format
                      }, defaultTransformSource));

                    case 19:
                      _ref3 = _context7.sent;
                      transformedSource = _ref3.source;
                      source = transformedSource;

                    case 22:
                      return _context7.abrupt("return", {
                        format: format,
                        source: source
                      });

                    case 23:
                    case "end":
                      return _context7.stop();
                  }
                }
              });
            }));

          case 1:
          case "end":
            return _context8.stop();
        }
      }
    });
  }

  function getFormat(url, context, defaultGetFormat) {
    var defer, entrypointFallback, parsed, pathname, nativePath, nodeSays, ext, tsNodeIgnored, nodeEquivalentExt, _tsNodeService$module, moduleType;

    return regeneratorRuntime.async(function getFormat$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            entrypointFallback = function _ref4(cb) {
              return regeneratorRuntime.async(function entrypointFallback$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      _context9.prev = 0;
                      _context9.next = 3;
                      return regeneratorRuntime.awrap(cb());

                    case 3:
                      return _context9.abrupt("return", _context9.sent);

                    case 6:
                      _context9.prev = 6;
                      _context9.t0 = _context9["catch"](0);

                      if (rememberIsProbablyEntrypoint.has(url)) {
                        _context9.next = 10;
                        break;
                      }

                      throw _context9.t0;

                    case 10:
                      return _context9.abrupt("return", {
                        format: 'commonjs'
                      });

                    case 11:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, null, null, [[0, 6]]);
            };

            defer = function defer() {
              var overrideUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : url;
              return defaultGetFormat(overrideUrl, context, defaultGetFormat);
            }; // See: https://github.com/nodejs/node/discussions/41711
            // nodejs will likely implement a similar fallback.  Till then, we can do our users a favor and fallback today.


            parsed = (0, url_1.parse)(url);

            if (isFileUrlOrNodeStyleSpecifier(parsed)) {
              _context10.next = 5;
              break;
            }

            return _context10.abrupt("return", entrypointFallback(defer));

          case 5:
            pathname = parsed.pathname;
            assert(pathname !== null, 'ESM getFormat() hook: URL should never have null pathname');
            nativePath = (0, url_1.fileURLToPath)(url);
            // If file has extension not understood by node, then ask node how it would treat the emitted extension.
            // E.g. .mts compiles to .mjs, so ask node how to classify an .mjs file.
            ext = (0, path_1.extname)(nativePath);
            tsNodeIgnored = tsNodeService.ignored(nativePath);
            nodeEquivalentExt = extensions.nodeEquivalents.get(ext);

            if (!(nodeEquivalentExt && !tsNodeIgnored)) {
              _context10.next = 17;
              break;
            }

            _context10.next = 14;
            return regeneratorRuntime.awrap(entrypointFallback(function () {
              return defer((0, url_1.format)((0, url_1.pathToFileURL)(nativePath + nodeEquivalentExt)));
            }));

          case 14:
            nodeSays = _context10.sent;
            _context10.next = 27;
            break;

          case 17:
            _context10.prev = 17;
            _context10.next = 20;
            return regeneratorRuntime.awrap(entrypointFallback(defer));

          case 20:
            nodeSays = _context10.sent;
            _context10.next = 27;
            break;

          case 23:
            _context10.prev = 23;
            _context10.t0 = _context10["catch"](17);

            if (_context10.t0 instanceof Error && tsNodeIgnored && extensions.nodeDoesNotUnderstand.includes(ext)) {
              _context10.t0.message += "\n\n" + "Hint:\n" + "ts-node is configured to ignore this file.\n" + "If you want ts-node to handle this file, consider enabling the \"skipIgnore\" option or adjusting your \"ignore\" patterns.\n" + "https://typestrong.org/ts-node/docs/scope\n";
            }

            throw _context10.t0;

          case 27:
            if (!(!tsNodeService.ignored(nativePath) && (nodeSays.format === 'commonjs' || nodeSays.format === 'module'))) {
              _context10.next = 35;
              break;
            }

            _tsNodeService$module = tsNodeService.moduleTypeClassifier.classifyModuleByModuleTypeOverrides((0, util_1.normalizeSlashes)(nativePath)), moduleType = _tsNodeService$module.moduleType;

            if (!(moduleType === 'cjs')) {
              _context10.next = 33;
              break;
            }

            return _context10.abrupt("return", {
              format: 'commonjs'
            });

          case 33:
            if (!(moduleType === 'esm')) {
              _context10.next = 35;
              break;
            }

            return _context10.abrupt("return", {
              format: 'module'
            });

          case 35:
            return _context10.abrupt("return", nodeSays);

          case 36:
          case "end":
            return _context10.stop();
        }
      }
    }, null, null, [[17, 23]]);
  }

  function transformSource(source, context, defaultTransformSource) {
    var defer, sourceAsString, url, parsed, nativePath, emittedJs;
    return regeneratorRuntime.async(function transformSource$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            if (!(source === null || source === undefined)) {
              _context11.next = 2;
              break;
            }

            throw new Error('No source');

          case 2:
            defer = function defer() {
              return defaultTransformSource(source, context, defaultTransformSource);
            };

            sourceAsString = typeof source === 'string' ? source : source.toString('utf8');
            url = context.url;
            parsed = (0, url_1.parse)(url);

            if (isFileUrlOrNodeStyleSpecifier(parsed)) {
              _context11.next = 8;
              break;
            }

            return _context11.abrupt("return", defer());

          case 8:
            nativePath = (0, url_1.fileURLToPath)(url);

            if (!tsNodeService.ignored(nativePath)) {
              _context11.next = 11;
              break;
            }

            return _context11.abrupt("return", defer());

          case 11:
            emittedJs = tsNodeService.compile(sourceAsString, nativePath);
            return _context11.abrupt("return", {
              source: emittedJs
            });

          case 13:
          case "end":
            return _context11.stop();
        }
      }
    });
  }

  return hooksAPI;
}

exports.createEsmHooks = createEsmHooks;

function addShortCircuitFlag(fn) {
  var ret;
  return regeneratorRuntime.async(function addShortCircuitFlag$(_context12) {
    while (1) {
      switch (_context12.prev = _context12.next) {
        case 0:
          _context12.next = 2;
          return regeneratorRuntime.awrap(fn());

        case 2:
          ret = _context12.sent;

          if (!(ret == null)) {
            _context12.next = 5;
            break;
          }

          return _context12.abrupt("return", ret);

        case 5:
          return _context12.abrupt("return", _objectSpread({}, ret, {
            shortCircuit: true
          }));

        case 6:
        case "end":
          return _context12.stop();
      }
    }
  });
}