"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getExtensions = void 0;

var util_1 = require("./util");

var nodeEquivalents = new Map([['.ts', '.js'], ['.tsx', '.js'], ['.jsx', '.js'], ['.mts', '.mjs'], ['.cts', '.cjs']]);
var tsResolverEquivalents = new Map([['.ts', ['.js']], ['.tsx', ['.js', '.jsx']], ['.mts', ['.mjs']], ['.cts', ['.cjs']]]); // All extensions understood by vanilla node

var vanillaNodeExtensions = ['.js', '.json', '.node', '.mjs', '.cjs']; // Extensions added by vanilla node's require() if you omit them:
// js, json, node
// Extensions added by vanilla node if you omit them with --experimental-specifier-resolution=node
// js, json, node, mjs
// Extensions added by ESM codepath's legacy package.json "main" resolver
// js, json, node (not mjs!)

var nodeDoesNotUnderstand = ['.ts', '.tsx', '.jsx', '.cts', '.mts'];
/**
 * [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]
 * @internal
 */

function getExtensions(config, options, tsVersion) {
  // TS 4.5 is first version to understand .cts, .mts, .cjs, and .mjs extensions
  var tsSupportsMtsCtsExts = (0, util_1.versionGteLt)(tsVersion, '4.5.0');
  var requiresHigherTypescriptVersion = [];
  if (!tsSupportsMtsCtsExts) requiresHigherTypescriptVersion.push('.cts', '.cjs', '.mts', '.mjs');
  var allPossibleExtensionsSortedByPreference = Array.from(new Set([].concat(_toConsumableArray(options.preferTsExts ? nodeDoesNotUnderstand : []), vanillaNodeExtensions, nodeDoesNotUnderstand)));
  var compiledJsUnsorted = ['.ts'];
  var compiledJsxUnsorted = [];
  if (config.options.jsx) compiledJsxUnsorted.push('.tsx');
  if (tsSupportsMtsCtsExts) compiledJsUnsorted.push('.mts', '.cts');

  if (config.options.allowJs) {
    compiledJsUnsorted.push('.js');
    if (config.options.jsx) compiledJsxUnsorted.push('.jsx');
    if (tsSupportsMtsCtsExts) compiledJsUnsorted.push('.mjs', '.cjs');
  }

  var compiledUnsorted = [].concat(compiledJsUnsorted, compiledJsxUnsorted);
  var compiled = allPossibleExtensionsSortedByPreference.filter(function (ext) {
    return compiledUnsorted.includes(ext);
  });
  var compiledNodeDoesNotUnderstand = nodeDoesNotUnderstand.filter(function (ext) {
    return compiled.includes(ext);
  });
  /**
   * TS's resolver can resolve foo.js to foo.ts, by replacing .js extension with several source extensions.
   * IMPORTANT: Must preserve ordering according to preferTsExts!
   *            Must include the .js/.mjs/.cjs extension in the array!
   *            This affects resolution behavior!
   * [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]
   */

  var r = allPossibleExtensionsSortedByPreference.filter(function (ext) {
    return [].concat(_toConsumableArray(compiledUnsorted), ['.js', '.mjs', '.cjs', '.mts', '.cts']).includes(ext);
  });
  var replacementsForJs = r.filter(function (ext) {
    return ['.js', '.jsx', '.ts', '.tsx'].includes(ext);
  });
  var replacementsForJsx = r.filter(function (ext) {
    return ['.jsx', '.tsx'].includes(ext);
  });
  var replacementsForMjs = r.filter(function (ext) {
    return ['.mjs', '.mts'].includes(ext);
  });
  var replacementsForCjs = r.filter(function (ext) {
    return ['.cjs', '.cts'].includes(ext);
  });
  var replacementsForJsOrMjs = r.filter(function (ext) {
    return ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.mts'].includes(ext);
  }); // Node allows omitting .js or .mjs extension in certain situations (CJS, ESM w/experimental flag)
  // So anything that compiles to .js or .mjs can also be omitted.

  var experimentalSpecifierResolutionAddsIfOmitted = Array.from(new Set([].concat(_toConsumableArray(replacementsForJsOrMjs), ['.json', '.node']))); // Same as above, except node curiuosly doesn't do .mjs here

  var legacyMainResolveAddsIfOmitted = Array.from(new Set([].concat(_toConsumableArray(replacementsForJs), ['.json', '.node'])));
  return {
    /** All file extensions we transform, ordered by resolution preference according to preferTsExts */
    compiled: compiled,

    /** Resolved extensions that vanilla node will not understand; we should handle them */
    nodeDoesNotUnderstand: nodeDoesNotUnderstand,

    /** Like the above, but only the ones we're compiling */
    compiledNodeDoesNotUnderstand: compiledNodeDoesNotUnderstand,

    /**
     * Mapping from extensions understood by tsc to the equivalent for node,
     * as far as getFormat is concerned.
     */
    nodeEquivalents: nodeEquivalents,

    /**
     * Mapping from extensions rejected by TSC in import specifiers, to the
     * possible alternatives that TS's resolver will accept.
     *
     * When we allow users to opt-in to .ts extensions in import specifiers, TS's
     * resolver requires us to replace the .ts extensions with .js alternatives.
     * Otherwise, resolution fails.
     *
     * Note TS's resolver is only used by, and only required for, typechecking.
     * This is separate from node's resolver, which we hook separately and which
     * does not require this mapping.
     */
    tsResolverEquivalents: tsResolverEquivalents,

    /**
     * Extensions that we can support if the user upgrades their typescript version.
     * Used when raising hints.
     */
    requiresHigherTypescriptVersion: requiresHigherTypescriptVersion,

    /**
     * --experimental-specifier-resolution=node will add these extensions.
     */
    experimentalSpecifierResolutionAddsIfOmitted: experimentalSpecifierResolutionAddsIfOmitted,

    /**
     * ESM loader will add these extensions to package.json "main" field
     */
    legacyMainResolveAddsIfOmitted: legacyMainResolveAddsIfOmitted,
    replacementsForMjs: replacementsForMjs,
    replacementsForCjs: replacementsForCjs,
    replacementsForJsx: replacementsForJsx,
    replacementsForJs: replacementsForJs
  };
}

exports.getExtensions = getExtensions;