/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;

var __copyProps = function __copyProps(to, from, except, desc) {
  if (from && _typeof(from) === "object" || typeof from === "function") {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      var _loop = function _loop() {
        var key = _step.value;
        if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
          get: function get() {
            return from[key];
          },
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
      };

      for (var _iterator = __getOwnPropNames(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        _loop();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return to;
};

var __toESM = function __toESM(mod, isNodeMode, target) {
  return target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps( // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
    value: mod,
    enumerable: true
  }) : target, mod);
}; // src/cancellationToken/cancellationToken.ts


var fs = __toESM(require("fs"));

function pipeExists(name) {
  return fs.existsSync(name);
}

function createCancellationToken(args) {
  var cancellationPipeName;

  for (var i = 0; i < args.length - 1; i++) {
    if (args[i] === "--cancellationPipeName") {
      cancellationPipeName = args[i + 1];
      break;
    }
  }

  if (!cancellationPipeName) {
    return {
      isCancellationRequested: function isCancellationRequested() {
        return false;
      },
      setRequest: function setRequest(_requestId) {
        return void 0;
      },
      resetRequest: function resetRequest(_requestId) {
        return void 0;
      }
    };
  }

  if (cancellationPipeName.charAt(cancellationPipeName.length - 1) === "*") {
    var namePrefix = cancellationPipeName.slice(0, -1);

    if (namePrefix.length === 0 || namePrefix.includes("*")) {
      throw new Error("Invalid name for template cancellation pipe: it should have length greater than 2 characters and contain only one '*'.");
    }

    var perRequestPipeName;
    var currentRequestId;
    return {
      isCancellationRequested: function isCancellationRequested() {
        return perRequestPipeName !== void 0 && pipeExists(perRequestPipeName);
      },
      setRequest: function setRequest(requestId) {
        currentRequestId = requestId;
        perRequestPipeName = namePrefix + requestId;
      },
      resetRequest: function resetRequest(requestId) {
        if (currentRequestId !== requestId) {
          throw new Error("Mismatched request id, expected ".concat(currentRequestId, ", actual ").concat(requestId));
        }

        perRequestPipeName = void 0;
      }
    };
  } else {
    return {
      isCancellationRequested: function isCancellationRequested() {
        return pipeExists(cancellationPipeName);
      },
      setRequest: function setRequest(_requestId) {
        return void 0;
      },
      resetRequest: function resetRequest(_requestId) {
        return void 0;
      }
    };
  }
}

module.exports = createCancellationToken;