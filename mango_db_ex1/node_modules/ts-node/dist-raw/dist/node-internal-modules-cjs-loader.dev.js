// Copied from several files in node's source code.
// https://github.com/nodejs/node/blob/2d5d77306f6dff9110c1f77fefab25f973415770/lib/internal/modules/cjs/loader.js
// Each function and variable below must have a comment linking to the source in node's github repo.
'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _require = require('./node-primordials'),
    ArrayIsArray = _require.ArrayIsArray,
    ArrayPrototypeIncludes = _require.ArrayPrototypeIncludes,
    ArrayPrototypeJoin = _require.ArrayPrototypeJoin,
    ArrayPrototypePush = _require.ArrayPrototypePush,
    JSONParse = _require.JSONParse,
    ObjectKeys = _require.ObjectKeys,
    RegExpPrototypeTest = _require.RegExpPrototypeTest,
    SafeMap = _require.SafeMap,
    SafeWeakMap = _require.SafeWeakMap,
    StringPrototypeCharCodeAt = _require.StringPrototypeCharCodeAt,
    StringPrototypeEndsWith = _require.StringPrototypeEndsWith,
    StringPrototypeLastIndexOf = _require.StringPrototypeLastIndexOf,
    StringPrototypeIndexOf = _require.StringPrototypeIndexOf,
    StringPrototypeMatch = _require.StringPrototypeMatch,
    StringPrototypeSlice = _require.StringPrototypeSlice,
    StringPrototypeStartsWith = _require.StringPrototypeStartsWith;

var _require2 = require('./node-nativemodule'),
    NativeModule = _require2.NativeModule;

var _require3 = require('url'),
    pathToFileURL = _require3.pathToFileURL,
    fileURLToPath = _require3.fileURLToPath;

var fs = require('fs');

var path = require('path');

var sep = path.sep;

var _require4 = require('./node-internalBinding-fs'),
    internalModuleStat = _require4.internalModuleStat;

var packageJsonReader = require('./node-internal-modules-package_json_reader');

var _require5 = require('./node-internal-modules-cjs-helpers'),
    cjsConditions = _require5.cjsConditions;

var _require6 = require('./node-options'),
    getOptionValue = _require6.getOptionValue;

var preserveSymlinks = getOptionValue('--preserve-symlinks');
var preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');

var _require7 = require('../dist/util'),
    normalizeSlashes = _require7.normalizeSlashes;

var _require8 = require('./node-internal-errors'),
    createErrRequireEsm = _require8.createErrRequireEsm;

var _require9 = require('./node-internal-errors'),
    ERR_INVALID_MODULE_SPECIFIER = _require9.codes.ERR_INVALID_MODULE_SPECIFIER;

var _require10 = require('./node-internal-constants'),
    CHAR_FORWARD_SLASH = _require10.CHAR_FORWARD_SLASH;

var Module = require('module');

var isWindows = process.platform === 'win32';
var statCache = null;

function stat(filename) {
  filename = path.toNamespacedPath(filename);

  if (statCache !== null) {
    var _result = statCache.get(filename);

    if (_result !== undefined) return _result;
  }

  var result = internalModuleStat(filename);

  if (statCache !== null && result >= 0) {
    // Only set cache when `internalModuleStat(filename)` succeeds.
    statCache.set(filename, result);
  }

  return result;
} // Note:
// we cannot get access to node's internal cache, which is populated from
// within node's Module constructor.  So the cache here will always be empty.
// It's possible we could approximate our own cache by building it up with
// hacky workarounds, but it's not worth the complexity and flakiness.


var moduleParentCache = new SafeWeakMap(); // Given a module name, and a list of paths to test, returns the first
// matching file in the following precedence.
//
// require("a.<ext>")
//   -> a.<ext>
//
// require("a")
//   -> a
//   -> a.<ext>
//   -> a/index.<ext>

var packageJsonCache = new SafeMap();

function readPackage(requestPath) {
  var jsonPath = path.resolve(requestPath, 'package.json');
  var existing = packageJsonCache.get(jsonPath);
  if (existing !== undefined) return existing;
  var result = packageJsonReader.read(jsonPath);
  var json = result.containsKeys === false ? '{}' : result.string;

  if (json === undefined) {
    packageJsonCache.set(jsonPath, false);
    return false;
  }

  try {
    var parsed = JSONParse(json);
    var filtered = {
      name: parsed.name,
      main: parsed.main,
      exports: parsed.exports,
      imports: parsed.imports,
      type: parsed.type
    };
    packageJsonCache.set(jsonPath, filtered);
    return filtered;
  } catch (e) {
    e.path = jsonPath;
    e.message = 'Error parsing ' + jsonPath + ': ' + e.message;
    throw e;
  }
}

function readPackageScope(checkPath) {
  var rootSeparatorIndex = StringPrototypeIndexOf(checkPath, sep);
  var separatorIndex;

  do {
    separatorIndex = StringPrototypeLastIndexOf(checkPath, sep);
    checkPath = StringPrototypeSlice(checkPath, 0, separatorIndex);
    if (StringPrototypeEndsWith(checkPath, sep + 'node_modules')) return false;
    var pjson = readPackage(checkPath + sep);
    if (pjson) return {
      data: pjson,
      path: checkPath
    };
  } while (separatorIndex > rootSeparatorIndex);

  return false;
}
/**
 * @param {{
 *   nodeEsmResolver: ReturnType<typeof import('./node-internal-modules-esm-resolve').createResolve>,
 *   extensions: import('../src/file-extensions').Extensions,
 *   preferTsExts
 * }} opts
 */


function createCjsLoader(opts) {
  var nodeEsmResolver = opts.nodeEsmResolver,
      preferTsExts = opts.preferTsExts;
  var _opts$extensions = opts.extensions,
      replacementsForCjs = _opts$extensions.replacementsForCjs,
      replacementsForJs = _opts$extensions.replacementsForJs,
      replacementsForMjs = _opts$extensions.replacementsForMjs,
      replacementsForJsx = _opts$extensions.replacementsForJsx;
  var encodedSepRegEx = nodeEsmResolver.encodedSepRegEx,
      packageExportsResolve = nodeEsmResolver.packageExportsResolve,
      packageImportsResolve = nodeEsmResolver.packageImportsResolve;

  function tryPackage(requestPath, exts, isMain, originalPath) {
    // const pkg = readPackage(requestPath)?.main;
    var tmp = readPackage(requestPath);
    var pkg = tmp != null ? tmp.main : undefined;

    if (!pkg) {
      return tryExtensions(path.resolve(requestPath, 'index'), exts, isMain);
    }

    var filename = path.resolve(requestPath, pkg);
    var actual = tryReplacementExtensions(filename, isMain) || tryFile(filename, isMain) || tryExtensions(filename, exts, isMain) || tryExtensions(path.resolve(filename, 'index'), exts, isMain);

    if (actual === false) {
      actual = tryExtensions(path.resolve(requestPath, 'index'), exts, isMain);

      if (!actual) {
        // eslint-disable-next-line no-restricted-syntax
        var err = new Error("Cannot find module '".concat(filename, "'. ") + 'Please verify that the package.json has a valid "main" entry');
        err.code = 'MODULE_NOT_FOUND';
        err.path = path.resolve(requestPath, 'package.json');
        err.requestPath = originalPath; // TODO(BridgeAR): Add the requireStack as well.

        throw err;
      } else {
        var jsonPath = path.resolve(requestPath, 'package.json');
        process.emitWarning("Invalid 'main' field in '".concat(jsonPath, "' of '").concat(pkg, "'. ") + 'Please either fix that or report it to the module author', 'DeprecationWarning', 'DEP0128');
      }
    }

    return actual;
  } // In order to minimize unnecessary lstat() calls,
  // this cache is a list of known-real paths.
  // Set to an empty Map to reset.


  var realpathCache = new SafeMap(); // Check if the file exists and is not a directory
  // if using --preserve-symlinks and isMain is false,
  // keep symlinks intact, otherwise resolve to the
  // absolute realpath.

  function tryFile(requestPath, isMain) {
    var rc = stat(requestPath);
    if (rc !== 0) return;

    if (preserveSymlinks && !isMain) {
      return path.resolve(requestPath);
    }

    return toRealPath(requestPath);
  }

  function toRealPath(requestPath) {
    return fs.realpathSync(requestPath, {// [internalFS.realpathCacheKey]: realpathCache
    });
  }

  function statReplacementExtensions(p) {
    var lastDotIndex = p.lastIndexOf('.');

    if (lastDotIndex >= 0) {
      var ext = p.slice(lastDotIndex);

      if (ext === '.js' || ext === '.jsx' || ext === '.mjs' || ext === '.cjs') {
        var pathnameWithoutExtension = p.slice(0, lastDotIndex);
        var replacementExts = ext === '.js' ? replacementsForJs : ext === '.jsx' ? replacementsForJsx : ext === '.mjs' ? replacementsForMjs : replacementsForCjs;

        for (var i = 0; i < replacementExts.length; i++) {
          var filename = pathnameWithoutExtension + replacementExts[i];
          var rc = stat(filename);

          if (rc === 0) {
            return [rc, filename];
          }
        }
      }
    }

    return [stat(p), p];
  }

  function tryReplacementExtensions(p, isMain) {
    var lastDotIndex = p.lastIndexOf('.');

    if (lastDotIndex >= 0) {
      var ext = p.slice(lastDotIndex);

      if (ext === '.js' || ext === '.jsx' || ext === '.mjs' || ext === '.cjs') {
        var pathnameWithoutExtension = p.slice(0, lastDotIndex);
        var replacementExts = ext === '.js' ? replacementsForJs : ext === '.jsx' ? replacementsForJsx : ext === '.mjs' ? replacementsForMjs : replacementsForCjs;

        for (var i = 0; i < replacementExts.length; i++) {
          var filename = tryFile(pathnameWithoutExtension + replacementExts[i], isMain);

          if (filename) {
            return filename;
          }
        }
      }
    }

    return false;
  } // Given a path, check if the file exists with any of the set extensions


  function tryExtensions(p, exts, isMain) {
    for (var i = 0; i < exts.length; i++) {
      var filename = tryFile(p + exts[i], isMain);

      if (filename) {
        return filename;
      }
    }

    return false;
  }

  function trySelfParentPath(parent) {
    if (!parent) return false;

    if (parent.filename) {
      return parent.filename;
    } else if (parent.id === '<repl>' || parent.id === 'internal/preload') {
      try {
        return process.cwd() + path.sep;
      } catch (_unused) {
        return false;
      }
    }
  }

  function trySelf(parentPath, request) {
    if (!parentPath) return false;

    var _ref = readPackageScope(parentPath) || {},
        pkg = _ref.data,
        pkgPath = _ref.path;

    if (!pkg || pkg.exports === undefined) return false;
    if (typeof pkg.name !== 'string') return false;
    var expansion;

    if (request === pkg.name) {
      expansion = '.';
    } else if (StringPrototypeStartsWith(request, "".concat(pkg.name, "/"))) {
      expansion = '.' + StringPrototypeSlice(request, pkg.name.length);
    } else {
      return false;
    }

    try {
      return finalizeEsmResolution(packageExportsResolve(pathToFileURL(pkgPath + '/package.json'), expansion, pkg, pathToFileURL(parentPath), cjsConditions).resolved, parentPath, pkgPath);
    } catch (e) {
      if (e.code === 'ERR_MODULE_NOT_FOUND') throw createEsmNotFoundErr(request, pkgPath + '/package.json');
      throw e;
    }
  } // This only applies to requests of a specific form:
  // 1. name/.*
  // 2. @scope/name/.*


  var EXPORTS_PATTERN = /^((?:@[^/\\%]+\/)?[^./\\%][^/\\%]*)(\/.*)?$/;

  function resolveExports(nmPath, request) {
    // The implementation's behavior is meant to mirror resolution in ESM.
    var _ref2 = StringPrototypeMatch(request, EXPORTS_PATTERN) || [],
        name = _ref2[1],
        _ref2$ = _ref2[2],
        expansion = _ref2$ === void 0 ? '' : _ref2$;

    if (!name) return;
    var pkgPath = path.resolve(nmPath, name);
    var pkg = readPackage(pkgPath); // if (pkg?.exports != null) {

    if (pkg != null && pkg.exports != null) {
      try {
        return finalizeEsmResolution(packageExportsResolve(pathToFileURL(pkgPath + '/package.json'), '.' + expansion, pkg, null, cjsConditions).resolved, null, pkgPath);
      } catch (e) {
        if (e.code === 'ERR_MODULE_NOT_FOUND') throw createEsmNotFoundErr(request, pkgPath + '/package.json');
        throw e;
      }
    }
  } // Backwards compat for old node versions


  var hasModulePathCache = !!require('module')._pathCache;
  var Module_pathCache = Object.create(null);
  var Module_pathCache_get = hasModulePathCache ? function (cacheKey) {
    return Module._pathCache[cacheKey];
  } : function (cacheKey) {
    return Module_pathCache[cacheKey];
  };
  var Module_pathCache_set = hasModulePathCache ? function (cacheKey, value) {
    return Module._pathCache[cacheKey] = value;
  } : function (cacheKey) {
    return Module_pathCache[cacheKey] = value;
  };
  var trailingSlashRegex = /(?:^|\/)\.?\.$/;

  var Module_findPath = function _findPath(request, paths, isMain) {
    var absoluteRequest = path.isAbsolute(request);

    if (absoluteRequest) {
      paths = [''];
    } else if (!paths || paths.length === 0) {
      return false;
    }

    var cacheKey = request + '\x00' + ArrayPrototypeJoin(paths, '\x00');
    var entry = Module_pathCache_get(cacheKey);
    if (entry) return entry;
    var exts;
    var trailingSlash = request.length > 0 && StringPrototypeCharCodeAt(request, request.length - 1) === CHAR_FORWARD_SLASH;

    if (!trailingSlash) {
      trailingSlash = RegExpPrototypeTest(trailingSlashRegex, request);
    } // For each path


    for (var i = 0; i < paths.length; i++) {
      // Don't search further if path doesn't exist
      var curPath = paths[i];
      if (curPath && stat(curPath) < 1) continue;

      if (!absoluteRequest) {
        var exportsResolved = resolveExports(curPath, request);
        if (exportsResolved) return exportsResolved;
      }

      var _basePath = path.resolve(curPath, request);

      var filename = void 0;

      var _statReplacementExten = statReplacementExtensions(_basePath),
          _statReplacementExten2 = _slicedToArray(_statReplacementExten, 2),
          rc = _statReplacementExten2[0],
          basePath = _statReplacementExten2[1];

      if (!trailingSlash) {
        if (rc === 0) {
          // File.
          if (!isMain) {
            if (preserveSymlinks) {
              filename = path.resolve(basePath);
            } else {
              filename = toRealPath(basePath);
            }
          } else if (preserveSymlinksMain) {
            // For the main module, we use the preserveSymlinksMain flag instead
            // mainly for backward compatibility, as the preserveSymlinks flag
            // historically has not applied to the main module.  Most likely this
            // was intended to keep .bin/ binaries working, as following those
            // symlinks is usually required for the imports in the corresponding
            // files to resolve; that said, in some use cases following symlinks
            // causes bigger problems which is why the preserveSymlinksMain option
            // is needed.
            filename = path.resolve(basePath);
          } else {
            filename = toRealPath(basePath);
          }
        }

        if (!filename) {
          // Try it with each of the extensions
          if (exts === undefined) exts = ObjectKeys(Module._extensions);
          filename = tryExtensions(basePath, exts, isMain);
        }
      }

      if (!filename && rc === 1) {
        // Directory.
        // try it with each of the extensions at "index"
        if (exts === undefined) exts = ObjectKeys(Module._extensions);
        filename = tryPackage(basePath, exts, isMain, request);
      }

      if (filename) {
        Module_pathCache_set(cacheKey, filename);
        return filename;
      }
    }

    return false;
  };

  var Module_resolveFilename = function _resolveFilename(request, parent, isMain, options) {
    if (StringPrototypeStartsWith(request, 'node:') || NativeModule.canBeRequiredByUsers(request)) {
      return request;
    }

    var paths;

    if (_typeof(options) === 'object' && options !== null) {
      if (ArrayIsArray(options.paths)) {
        var isRelative = StringPrototypeStartsWith(request, './') || StringPrototypeStartsWith(request, '../') || isWindows && StringPrototypeStartsWith(request, '.\\') || StringPrototypeStartsWith(request, '..\\');

        if (isRelative) {
          paths = options.paths;
        } else {
          var fakeParent = new Module('', null);
          paths = [];

          for (var i = 0; i < options.paths.length; i++) {
            var _path = options.paths[i];
            fakeParent.paths = Module._nodeModulePaths(_path);

            var lookupPaths = Module._resolveLookupPaths(request, fakeParent);

            for (var j = 0; j < lookupPaths.length; j++) {
              if (!ArrayPrototypeIncludes(paths, lookupPaths[j])) ArrayPrototypePush(paths, lookupPaths[j]);
            }
          }
        }
      } else if (options.paths === undefined) {
        paths = Module._resolveLookupPaths(request, parent);
      } else {
        throw new ERR_INVALID_ARG_VALUE('options.paths', options.paths);
      }
    } else {
      paths = Module._resolveLookupPaths(request, parent);
    } // if (parent?.filename) {
    // node 12 hack


    if (parent != null && parent.filename) {
      if (request[0] === '#') {
        var pkg = readPackageScope(parent.filename) || {}; // if (pkg.data?.imports != null) {
        // node 12 hack

        if (pkg.data != null && pkg.data.imports != null) {
          try {
            return finalizeEsmResolution(packageImportsResolve(request, pathToFileURL(parent.filename), cjsConditions), parent.filename, pkg.path);
          } catch (e) {
            if (e.code === 'ERR_MODULE_NOT_FOUND') throw createEsmNotFoundErr(request);
            throw e;
          }
        }
      }
    } // Try module self resolution first


    var parentPath = trySelfParentPath(parent);
    var selfResolved = trySelf(parentPath, request);

    if (selfResolved) {
      var cacheKey = request + '\x00' + (paths.length === 1 ? paths[0] : ArrayPrototypeJoin(paths, '\x00'));
      Module._pathCache[cacheKey] = selfResolved;
      return selfResolved;
    } // Look up the filename first, since that's the cache key.


    var filename = Module._findPath(request, paths, isMain, false);

    if (filename) return filename;
    var requireStack = [];

    for (var cursor = parent; cursor; cursor = moduleParentCache.get(cursor)) {
      ArrayPrototypePush(requireStack, cursor.filename || cursor.id);
    }

    var message = "Cannot find module '".concat(request, "'");

    if (requireStack.length > 0) {
      message = message + '\nRequire stack:\n- ' + ArrayPrototypeJoin(requireStack, '\n- ');
    } // eslint-disable-next-line no-restricted-syntax


    var err = new Error(message);
    err.code = 'MODULE_NOT_FOUND';
    err.requireStack = requireStack;
    throw err;
  };

  function finalizeEsmResolution(resolved, parentPath, pkgPath) {
    if (RegExpPrototypeTest(encodedSepRegEx, resolved)) throw new ERR_INVALID_MODULE_SPECIFIER(resolved, 'must not include encoded "/" or "\\" characters', parentPath);
    var filename = fileURLToPath(resolved);
    var actual = tryReplacementExtensions(filename) || tryFile(filename);
    if (actual) return actual;
    var err = createEsmNotFoundErr(filename, path.resolve(pkgPath, 'package.json'));
    throw err;
  }

  function createEsmNotFoundErr(request, path) {
    // eslint-disable-next-line no-restricted-syntax
    var err = new Error("Cannot find module '".concat(request, "'"));
    err.code = 'MODULE_NOT_FOUND';
    if (path) err.path = path; // TODO(BridgeAR): Add the requireStack as well.

    return err;
  }

  return {
    Module_findPath: Module_findPath,
    Module_resolveFilename: Module_resolveFilename
  };
}
/**
 * copied from Module._extensions['.js']
 * https://github.com/nodejs/node/blob/v15.3.0/lib/internal/modules/cjs/loader.js#L1113-L1120
 * @param {import('../src/index').Service} service
 * @param {NodeJS.Module} module
 * @param {string} filename
 */


function assertScriptCanLoadAsCJSImpl(service, module, filename) {
  var pkg = readPackageScope(filename); // ts-node modification: allow our configuration to override

  var tsNodeClassification = service.moduleTypeClassifier.classifyModuleByModuleTypeOverrides(normalizeSlashes(filename));
  if (tsNodeClassification.moduleType === 'cjs') return; // ignore package.json when file extension is ESM-only or CJS-only
  // [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]

  var lastDotIndex = filename.lastIndexOf('.');
  var ext = lastDotIndex >= 0 ? filename.slice(lastDotIndex) : '';
  if ((ext === '.cts' || ext === '.cjs') && tsNodeClassification.moduleType === 'auto') return; // Function require shouldn't be used in ES modules.

  if (ext === '.mts' || ext === '.mjs' || tsNodeClassification.moduleType === 'esm' || pkg && pkg.data && pkg.data.type === 'module') {
    var parentPath = module.parent && module.parent.filename;
    var packageJsonPath = pkg ? path.resolve(pkg.path, 'package.json') : null;
    throw createErrRequireEsm(filename, parentPath, packageJsonPath);
  }
}

module.exports = {
  createCjsLoader: createCjsLoader,
  assertScriptCanLoadAsCJSImpl: assertScriptCanLoadAsCJSImpl,
  readPackageScope: readPackageScope
};