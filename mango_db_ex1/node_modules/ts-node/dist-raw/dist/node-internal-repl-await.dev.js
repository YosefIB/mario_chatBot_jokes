// copied from https://github.com/nodejs/node/blob/88799930794045795e8abac874730f9eba7e2300/lib/internal/repl/await.js
'use strict';

var _require = require('./node-primordials'),
    ArrayFrom = _require.ArrayFrom,
    ArrayPrototypeForEach = _require.ArrayPrototypeForEach,
    ArrayPrototypeIncludes = _require.ArrayPrototypeIncludes,
    ArrayPrototypeJoin = _require.ArrayPrototypeJoin,
    ArrayPrototypePop = _require.ArrayPrototypePop,
    ArrayPrototypePush = _require.ArrayPrototypePush,
    FunctionPrototype = _require.FunctionPrototype,
    ObjectKeys = _require.ObjectKeys,
    RegExpPrototypeSymbolReplace = _require.RegExpPrototypeSymbolReplace,
    StringPrototypeEndsWith = _require.StringPrototypeEndsWith,
    StringPrototypeIncludes = _require.StringPrototypeIncludes,
    StringPrototypeIndexOf = _require.StringPrototypeIndexOf,
    StringPrototypeRepeat = _require.StringPrototypeRepeat,
    StringPrototypeSplit = _require.StringPrototypeSplit,
    StringPrototypeStartsWith = _require.StringPrototypeStartsWith,
    SyntaxError = _require.SyntaxError;

var parser = require('acorn').Parser;

var walk = require('acorn-walk');

var _require2 = require('repl'),
    Recoverable = _require2.Recoverable;

function isTopLevelDeclaration(state) {
  return state.ancestors[state.ancestors.length - 2] === state.body;
}

var noop = FunctionPrototype;
var visitorsWithoutAncestors = {
  ClassDeclaration: function ClassDeclaration(node, state, c) {
    if (isTopLevelDeclaration(state)) {
      state.prepend(node, "".concat(node.id.name, "="));
      ArrayPrototypePush(state.hoistedDeclarationStatements, "let ".concat(node.id.name, "; "));
    }

    walk.base.ClassDeclaration(node, state, c);
  },
  ForOfStatement: function ForOfStatement(node, state, c) {
    if (node["await"] === true) {
      state.containsAwait = true;
    }

    walk.base.ForOfStatement(node, state, c);
  },
  FunctionDeclaration: function FunctionDeclaration(node, state, c) {
    state.prepend(node, "".concat(node.id.name, "="));
    ArrayPrototypePush(state.hoistedDeclarationStatements, "var ".concat(node.id.name, "; "));
  },
  FunctionExpression: noop,
  ArrowFunctionExpression: noop,
  MethodDefinition: noop,
  AwaitExpression: function AwaitExpression(node, state, c) {
    state.containsAwait = true;
    walk.base.AwaitExpression(node, state, c);
  },
  ReturnStatement: function ReturnStatement(node, state, c) {
    state.containsReturn = true;
    walk.base.ReturnStatement(node, state, c);
  },
  VariableDeclaration: function VariableDeclaration(node, state, c) {
    var variableKind = node.kind;
    var isIterableForDeclaration = ArrayPrototypeIncludes(['ForOfStatement', 'ForInStatement'], state.ancestors[state.ancestors.length - 2].type);

    if (variableKind === 'var' || isTopLevelDeclaration(state)) {
      var registerVariableDeclarationIdentifiers = function registerVariableDeclarationIdentifiers(node) {
        switch (node.type) {
          case 'Identifier':
            ArrayPrototypePush(variableIdentifiersToHoist[variableKind === 'var' ? 0 : 1][1], node.name);
            break;

          case 'ObjectPattern':
            ArrayPrototypeForEach(node.properties, function (property) {
              registerVariableDeclarationIdentifiers(property.value);
            });
            break;

          case 'ArrayPattern':
            ArrayPrototypeForEach(node.elements, function (element) {
              registerVariableDeclarationIdentifiers(element);
            });
            break;
        }
      };

      state.replace(node.start, node.start + variableKind.length + (isIterableForDeclaration ? 1 : 0), variableKind === 'var' && isIterableForDeclaration ? '' : 'void' + (node.declarations.length === 1 ? '' : ' ('));

      if (!isIterableForDeclaration) {
        ArrayPrototypeForEach(node.declarations, function (decl) {
          state.prepend(decl, '(');
          state.append(decl, decl.init ? ')' : '=undefined)');
        });

        if (node.declarations.length !== 1) {
          state.append(node.declarations[node.declarations.length - 1], ')');
        }
      }

      var variableIdentifiersToHoist = [['var', []], ['let', []]];
      ArrayPrototypeForEach(node.declarations, function (decl) {
        registerVariableDeclarationIdentifiers(decl.id);
      });
      ArrayPrototypeForEach(variableIdentifiersToHoist, function (_ref) {
        var kind = _ref[0],
            identifiers = _ref[1];

        if (identifiers.length > 0) {
          ArrayPrototypePush(state.hoistedDeclarationStatements, "".concat(kind, " ").concat(ArrayPrototypeJoin(identifiers, ', '), "; "));
        }
      });
    }

    walk.base.VariableDeclaration(node, state, c);
  }
};
var visitors = {};
var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = undefined;

try {
  var _loop = function _loop() {
    var nodeType = _step.value;
    var callback = visitorsWithoutAncestors[nodeType] || walk.base[nodeType];

    visitors[nodeType] = function (node, state, c) {
      var isNew = node !== state.ancestors[state.ancestors.length - 1];

      if (isNew) {
        ArrayPrototypePush(state.ancestors, node);
      }

      callback(node, state, c);

      if (isNew) {
        ArrayPrototypePop(state.ancestors);
      }
    };
  };

  for (var _iterator = ObjectKeys(walk.base)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    _loop();
  }
} catch (err) {
  _didIteratorError = true;
  _iteratorError = err;
} finally {
  try {
    if (!_iteratorNormalCompletion && _iterator["return"] != null) {
      _iterator["return"]();
    }
  } finally {
    if (_didIteratorError) {
      throw _iteratorError;
    }
  }
}

function processTopLevelAwait(src) {
  var wrapPrefix = '(async () => { ';
  var wrapped = "".concat(wrapPrefix).concat(src, " })()");
  var wrappedArray = ArrayFrom(wrapped);
  var root;

  try {
    root = parser.parse(wrapped, {
      ecmaVersion: 'latest'
    });
  } catch (e) {
    if (StringPrototypeStartsWith(e.message, 'Unterminated ')) throw new Recoverable(e); // If the parse error is before the first "await", then use the execution
    // error. Otherwise we must emit this parse error, making it look like a
    // proper syntax error.

    var awaitPos = StringPrototypeIndexOf(src, 'await');
    var errPos = e.pos - wrapPrefix.length;
    if (awaitPos > errPos) return null; // Convert keyword parse errors on await into their original errors when
    // possible.

    if (errPos === awaitPos + 6 && StringPrototypeIncludes(e.message, 'Expecting Unicode escape sequence')) return null;
    if (errPos === awaitPos + 7 && StringPrototypeIncludes(e.message, 'Unexpected token')) return null;
    var line = e.loc.line;
    var column = line === 1 ? e.loc.column - wrapPrefix.length : e.loc.column;
    var message = '\n' + StringPrototypeSplit(src, '\n')[line - 1] + '\n' + StringPrototypeRepeat(' ', column) + '^\n\n' + RegExpPrototypeSymbolReplace(/ \([^)]+\)/, e.message, ''); // V8 unexpected token errors include the token string.

    if (StringPrototypeEndsWith(message, 'Unexpected token')) message += " '" + ( // Wrapper end may cause acorn to report error position after the source
    src.length - 1 >= e.pos - wrapPrefix.length ? src[e.pos - wrapPrefix.length] : src[src.length - 1]) + "'"; // eslint-disable-next-line no-restricted-syntax

    throw new SyntaxError(message);
  }

  var body = root.body[0].expression.callee.body;
  var state = {
    body: body,
    ancestors: [],
    hoistedDeclarationStatements: [],
    replace: function replace(from, to, str) {
      for (var i = from; i < to; i++) {
        wrappedArray[i] = '';
      }

      if (from === to) str += wrappedArray[from];
      wrappedArray[from] = str;
    },
    prepend: function prepend(node, str) {
      wrappedArray[node.start] = str + wrappedArray[node.start];
    },
    append: function append(node, str) {
      wrappedArray[node.end - 1] += str;
    },
    containsAwait: false,
    containsReturn: false
  };
  walk.recursive(body, state, visitors); // Do not transform if
  // 1. False alarm: there isn't actually an await expression.
  // 2. There is a top-level return, which is not allowed.

  if (!state.containsAwait || state.containsReturn) {
    return null;
  }

  var last = body.body[body.body.length - 1];

  if (last.type === 'ExpressionStatement') {
    // For an expression statement of the form
    // ( expr ) ;
    // ^^^^^^^^^^   // last
    //   ^^^^       // last.expression
    //
    // We do not want the left parenthesis before the `return` keyword;
    // therefore we prepend the `return (` to `last`.
    //
    // On the other hand, we do not want the right parenthesis after the
    // semicolon. Since there can only be more right parentheses between
    // last.expression.end and the semicolon, appending one more to
    // last.expression should be fine.
    state.prepend(last, 'return (');
    state.append(last.expression, ')');
  }

  return ArrayPrototypeJoin(state.hoistedDeclarationStatements, '') + ArrayPrototypeJoin(wrappedArray, '');
}

module.exports = {
  processTopLevelAwait: processTopLevelAwait
};