"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEmitScriptTarget = exports.getUseDefineForClassFields = exports.getPatternFromSpec = exports.createTsInternals = void 0;

var path_1 = require("path");

var util_1 = require("./util");
/** @internal */


exports.createTsInternals = (0, util_1.cachedLookup)(createTsInternalsUncached);
/**
 * Given a reference to the TS compiler, return some TS internal functions that we
 * could not or did not want to grab off the `ts` object.
 * These have been copy-pasted from TS's source and tweaked as necessary.
 *
 * NOTE: This factory returns *only* functions which need a reference to the TS
 * compiler.  Other functions do not need a reference to the TS compiler so are
 * exported directly from this file.
 */

function createTsInternalsUncached(_ts) {
  var ts = _ts;
  /**
   * Copied from:
   * https://github.com/microsoft/TypeScript/blob/v4.3.2/src/compiler/commandLineParser.ts#L2821-L2846
   */

  function getExtendsConfigPath(extendedConfig, host, basePath, errors, createDiagnostic) {
    extendedConfig = (0, util_1.normalizeSlashes)(extendedConfig);

    if (isRootedDiskPath(extendedConfig) || startsWith(extendedConfig, './') || startsWith(extendedConfig, '../')) {
      var extendedConfigPath = getNormalizedAbsolutePath(extendedConfig, basePath);

      if (!host.fileExists(extendedConfigPath) && !endsWith(extendedConfigPath, ts.Extension.Json)) {
        extendedConfigPath = "".concat(extendedConfigPath, ".json");

        if (!host.fileExists(extendedConfigPath)) {
          errors.push(createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig));
          return undefined;
        }
      }

      return extendedConfigPath;
    } // If the path isn't a rooted or relative path, resolve like a module


    var tsGte5_3_0 = (0, util_1.versionGteLt)(ts.version, '5.3.0');
    var resolved = ts.nodeModuleNameResolver(extendedConfig, combinePaths(basePath, 'tsconfig.json'), {
      moduleResolution: ts.ModuleResolutionKind.NodeJs
    }, host,
    /*cache*/
    undefined,
    /*projectRefs*/
    undefined,
    /*conditionsOrIsConfigLookup*/
    tsGte5_3_0 ? undefined : true,
    /*isConfigLookup*/
    tsGte5_3_0 ? true : undefined);

    if (resolved.resolvedModule) {
      return resolved.resolvedModule.resolvedFileName;
    }

    errors.push(createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig));
    return undefined;
  }

  return {
    getExtendsConfigPath: getExtendsConfigPath
  };
} // These functions have alternative implementation to avoid copying too much from TS


function isRootedDiskPath(path) {
  return (0, path_1.isAbsolute)(path);
}

function combinePaths(path) {
  for (var _len = arguments.length, paths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    paths[_key - 1] = arguments[_key];
  }

  return (0, util_1.normalizeSlashes)((0, path_1.resolve).apply(void 0, [path].concat(_toConsumableArray(paths.filter(function (path) {
    return path;
  })))));
}

function getNormalizedAbsolutePath(fileName, currentDirectory) {
  return (0, util_1.normalizeSlashes)(currentDirectory != null ? (0, path_1.resolve)(currentDirectory, fileName) : (0, path_1.resolve)(fileName));
}

function startsWith(str, prefix) {
  return str.lastIndexOf(prefix, 0) === 0;
}

function endsWith(str, suffix) {
  var expectedPos = str.length - suffix.length;
  return expectedPos >= 0 && str.indexOf(suffix, expectedPos) === expectedPos;
} // Reserved characters, forces escaping of any non-word (or digit), non-whitespace character.
// It may be inefficient (we could just match (/[-[\]{}()*+?.,\\^$|#\s]/g), but this is future
// proof.


var reservedCharacterPattern = /[^\w\s\/]/g;
/**
 * @internal
 * See also: getRegularExpressionForWildcard, which seems to do almost the same thing
 */

function getPatternFromSpec(spec, basePath) {
  var pattern = spec && getSubPatternFromSpec(spec, basePath, excludeMatcher);
  return pattern && "^(".concat(pattern, ")", '($|/)');
}

exports.getPatternFromSpec = getPatternFromSpec;

function getSubPatternFromSpec(spec, basePath, _ref) {
  var singleAsteriskRegexFragment = _ref.singleAsteriskRegexFragment,
      doubleAsteriskRegexFragment = _ref.doubleAsteriskRegexFragment,
      replaceWildcardCharacter = _ref.replaceWildcardCharacter;
  var subpattern = '';
  var hasWrittenComponent = false;
  var components = getNormalizedPathComponents(spec, basePath);
  var lastComponent = last(components); // getNormalizedPathComponents includes the separator for the root component.
  // We need to remove to create our regex correctly.

  components[0] = removeTrailingDirectorySeparator(components[0]);

  if (isImplicitGlob(lastComponent)) {
    components.push('**', '*');
  }

  var optionalCount = 0;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = components[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var component = _step.value;

      if (component === '**') {
        subpattern += doubleAsteriskRegexFragment;
      } else {
        if (hasWrittenComponent) {
          subpattern += directorySeparator;
        }

        subpattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter);
      }

      hasWrittenComponent = true;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  while (optionalCount > 0) {
    subpattern += ')?';
    optionalCount--;
  }

  return subpattern;
}

var directoriesMatcher = {
  singleAsteriskRegexFragment: '[^/]*',

  /**
   * Regex for the ** wildcard. Matches any num of subdirectories. When used for including
   * files or directories, does not match subdirectories that start with a . character
   */
  doubleAsteriskRegexFragment: "(/[^/.][^/]*)*?",
  replaceWildcardCharacter: function replaceWildcardCharacter(match) {
    return _replaceWildcardCharacter(match, directoriesMatcher.singleAsteriskRegexFragment);
  }
};
var excludeMatcher = {
  singleAsteriskRegexFragment: '[^/]*',
  doubleAsteriskRegexFragment: '(/.+?)?',
  replaceWildcardCharacter: function replaceWildcardCharacter(match) {
    return _replaceWildcardCharacter(match, excludeMatcher.singleAsteriskRegexFragment);
  }
};

function getNormalizedPathComponents(path, currentDirectory) {
  return reducePathComponents(getPathComponents(path, currentDirectory));
}

function getPathComponents(path) {
  var currentDirectory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  path = combinePaths(currentDirectory, path);
  return pathComponents(path, getRootLength(path));
}

function reducePathComponents(components) {
  if (!some(components)) return [];
  var reduced = [components[0]];

  for (var i = 1; i < components.length; i++) {
    var component = components[i];
    if (!component) continue;
    if (component === '.') continue;

    if (component === '..') {
      if (reduced.length > 1) {
        if (reduced[reduced.length - 1] !== '..') {
          reduced.pop();
          continue;
        }
      } else if (reduced[0]) continue;
    }

    reduced.push(component);
  }

  return reduced;
}

function getRootLength(path) {
  var rootLength = getEncodedRootLength(path);
  return rootLength < 0 ? ~rootLength : rootLength;
}

function getEncodedRootLength(path) {
  if (!path) return 0;
  var ch0 = path.charCodeAt(0); // POSIX or UNC

  if (ch0 === 47
  /* CharacterCodes.slash */
  || ch0 === 92
  /* CharacterCodes.backslash */
  ) {
      if (path.charCodeAt(1) !== ch0) return 1; // POSIX: "/" (or non-normalized "\")

      var p1 = path.indexOf(ch0 === 47
      /* CharacterCodes.slash */
      ? directorySeparator : altDirectorySeparator, 2);
      if (p1 < 0) return path.length; // UNC: "//server" or "\\server"

      return p1 + 1; // UNC: "//server/" or "\\server\"
    } // DOS


  if (isVolumeCharacter(ch0) && path.charCodeAt(1) === 58
  /* CharacterCodes.colon */
  ) {
      var ch2 = path.charCodeAt(2);
      if (ch2 === 47
      /* CharacterCodes.slash */
      || ch2 === 92
      /* CharacterCodes.backslash */
      ) return 3; // DOS: "c:/" or "c:\"

      if (path.length === 2) return 2; // DOS: "c:" (but not "c:d")
    } // URL


  var schemeEnd = path.indexOf(urlSchemeSeparator);

  if (schemeEnd !== -1) {
    var authorityStart = schemeEnd + urlSchemeSeparator.length;
    var authorityEnd = path.indexOf(directorySeparator, authorityStart);

    if (authorityEnd !== -1) {
      // URL: "file:///", "file://server/", "file://server/path"
      // For local "file" URLs, include the leading DOS volume (if present).
      // Per https://www.ietf.org/rfc/rfc1738.txt, a host of "" or "localhost" is a
      // special case interpreted as "the machine from which the URL is being interpreted".
      var scheme = path.slice(0, schemeEnd);
      var authority = path.slice(authorityStart, authorityEnd);

      if (scheme === 'file' && (authority === '' || authority === 'localhost') && isVolumeCharacter(path.charCodeAt(authorityEnd + 1))) {
        var volumeSeparatorEnd = getFileUrlVolumeSeparatorEnd(path, authorityEnd + 2);

        if (volumeSeparatorEnd !== -1) {
          if (path.charCodeAt(volumeSeparatorEnd) === 47
          /* CharacterCodes.slash */
          ) {
              // URL: "file:///c:/", "file://localhost/c:/", "file:///c%3a/", "file://localhost/c%3a/"
              return ~(volumeSeparatorEnd + 1);
            }

          if (volumeSeparatorEnd === path.length) {
            // URL: "file:///c:", "file://localhost/c:", "file:///c$3a", "file://localhost/c%3a"
            // but not "file:///c:d" or "file:///c%3ad"
            return ~volumeSeparatorEnd;
          }
        }
      }

      return ~(authorityEnd + 1); // URL: "file://server/", "http://server/"
    }

    return ~path.length; // URL: "file://server", "http://server"
  } // relative


  return 0;
}

function ensureTrailingDirectorySeparator(path) {
  if (!hasTrailingDirectorySeparator(path)) {
    return path + directorySeparator;
  }

  return path;
}

function hasTrailingDirectorySeparator(path) {
  return path.length > 0 && isAnyDirectorySeparator(path.charCodeAt(path.length - 1));
}

function isAnyDirectorySeparator(charCode) {
  return charCode === 47
  /* CharacterCodes.slash */
  || charCode === 92
  /* CharacterCodes.backslash */
  ;
}

function removeTrailingDirectorySeparator(path) {
  if (hasTrailingDirectorySeparator(path)) {
    return path.substr(0, path.length - 1);
  }

  return path;
}

var directorySeparator = '/';
var altDirectorySeparator = '\\';
var urlSchemeSeparator = '://';

function isVolumeCharacter(charCode) {
  return charCode >= 97
  /* CharacterCodes.a */
  && charCode <= 122
  /* CharacterCodes.z */
  || charCode >= 65
  /* CharacterCodes.A */
  && charCode <= 90
  /* CharacterCodes.Z */
  ;
}

function getFileUrlVolumeSeparatorEnd(url, start) {
  var ch0 = url.charCodeAt(start);
  if (ch0 === 58
  /* CharacterCodes.colon */
  ) return start + 1;

  if (ch0 === 37
  /* CharacterCodes.percent */
  && url.charCodeAt(start + 1) === 51
  /* CharacterCodes._3 */
  ) {
      var ch2 = url.charCodeAt(start + 2);
      if (ch2 === 97
      /* CharacterCodes.a */
      || ch2 === 65
      /* CharacterCodes.A */
      ) return start + 3;
    }

  return -1;
}

function some(array, predicate) {
  if (array) {
    if (predicate) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = array[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var v = _step2.value;

          if (predicate(v)) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    } else {
      return array.length > 0;
    }
  }

  return false;
}

function pathComponents(path, rootLength) {
  var root = path.substring(0, rootLength);
  var rest = path.substring(rootLength).split(directorySeparator);
  if (rest.length && !lastOrUndefined(rest)) rest.pop();
  return [root].concat(_toConsumableArray(rest));
}

function lastOrUndefined(array) {
  return array.length === 0 ? undefined : array[array.length - 1];
}

function last(array) {
  // Debug.assert(array.length !== 0);
  return array[array.length - 1];
}

function _replaceWildcardCharacter(match, singleAsteriskRegexFragment) {
  return match === '*' ? singleAsteriskRegexFragment : match === '?' ? '[^/]' : '\\' + match;
}
/**
 * An "includes" path "foo" is implicitly a glob "foo/** /*" (without the space) if its last component has no extension,
 * and does not contain any glob characters itself.
 */


function isImplicitGlob(lastPathComponent) {
  return !/[.*?]/.test(lastPathComponent);
}

var ts_ScriptTarget_ES5 = 1;
var ts_ScriptTarget_ES2022 = 9;
var ts_ScriptTarget_ESNext = 99;
var ts_ModuleKind_Node16 = 100;
var ts_ModuleKind_NodeNext = 199; // https://github.com/microsoft/TypeScript/blob/fc418a2e611c88cf9afa0115ff73490b2397d311/src/compiler/utilities.ts#L8761

function getUseDefineForClassFields(compilerOptions) {
  return compilerOptions.useDefineForClassFields === undefined ? getEmitScriptTarget(compilerOptions) >= ts_ScriptTarget_ES2022 : compilerOptions.useDefineForClassFields;
}

exports.getUseDefineForClassFields = getUseDefineForClassFields; // https://github.com/microsoft/TypeScript/blob/fc418a2e611c88cf9afa0115ff73490b2397d311/src/compiler/utilities.ts#L8556

function getEmitScriptTarget(compilerOptions) {
  var _a;

  return (_a = compilerOptions.target) !== null && _a !== void 0 ? _a : compilerOptions.module === ts_ModuleKind_Node16 && ts_ScriptTarget_ES2022 || compilerOptions.module === ts_ModuleKind_NodeNext && ts_ScriptTarget_ESNext || ts_ScriptTarget_ES5;
}

exports.getEmitScriptTarget = getEmitScriptTarget;