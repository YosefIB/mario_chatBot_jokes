"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.callInChild = void 0;

var child_process_1 = require("child_process");

var url_1 = require("url");

var util_1 = require("../util");

var argv_payload_1 = require("./argv-payload");
/**
 * @internal
 * @param state Bootstrap state to be transferred into the child process.
 * @param targetCwd Working directory to be preserved when transitioning to
 *   the child process.
 */


function callInChild(state) {
  if (!(0, util_1.versionGteLt)(process.versions.node, '12.17.0')) {
    throw new Error('`ts-node-esm` and `ts-node --esm` require node version 12.17.0 or newer.');
  }

  var child = (0, child_process_1.spawn)(process.execPath, ['--require', require.resolve('./child-require.js'), '--loader', // Node on Windows doesn't like `c:\` absolute paths here; must be `file:///c:/`
  (0, url_1.pathToFileURL)(require.resolve('../../child-loader.mjs')).toString(), require.resolve('./child-entrypoint.js'), "".concat(argv_payload_1.argPrefix).concat((0, argv_payload_1.compress)(state))].concat(_toConsumableArray(state.parseArgvResult.restArgs)), {
    stdio: 'inherit',
    argv0: process.argv0
  });
  child.on('error', function (error) {
    console.error(error);
    process.exit(1);
  });
  child.on('exit', function (code) {
    child.removeAllListeners();
    process.off('SIGINT', sendSignalToChild);
    process.off('SIGTERM', sendSignalToChild);
    process.exitCode = code === null ? 1 : code;
  }); // Ignore sigint and sigterm in parent; pass them to child

  process.on('SIGINT', sendSignalToChild);
  process.on('SIGTERM', sendSignalToChild);

  function sendSignalToChild(signal) {
    process.kill(child.pid, signal);
  }
}

exports.callInChild = callInChild;