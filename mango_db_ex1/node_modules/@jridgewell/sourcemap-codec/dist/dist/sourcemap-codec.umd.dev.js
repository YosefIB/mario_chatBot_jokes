"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.sourcemapCodec = {}));
})(void 0, function (exports) {
  'use strict';

  var comma = ','.charCodeAt(0);
  var semicolon = ';'.charCodeAt(0);
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  var intToChar = new Uint8Array(64); // 64 possible chars.

  var charToInt = new Uint8Array(128); // z is 122 in ASCII

  for (var i = 0; i < chars.length; i++) {
    var c = chars.charCodeAt(i);
    intToChar[i] = c;
    charToInt[c] = i;
  }

  function decodeInteger(reader, relative) {
    var value = 0;
    var shift = 0;
    var integer = 0;

    do {
      var _c = reader.next();

      integer = charToInt[_c];
      value |= (integer & 31) << shift;
      shift += 5;
    } while (integer & 32);

    var shouldNegate = value & 1;
    value >>>= 1;

    if (shouldNegate) {
      value = -0x80000000 | -value;
    }

    return relative + value;
  }

  function encodeInteger(builder, num, relative) {
    var delta = num - relative;
    delta = delta < 0 ? -delta << 1 | 1 : delta << 1;

    do {
      var clamped = delta & 31;
      delta >>>= 5;
      if (delta > 0) clamped |= 32;
      builder.write(intToChar[clamped]);
    } while (delta > 0);

    return num;
  }

  function hasMoreVlq(reader, max) {
    if (reader.pos >= max) return false;
    return reader.peek() !== comma;
  }

  var bufLength = 1024 * 16; // Provide a fallback for older environments.

  var td = typeof TextDecoder !== 'undefined' ?
  /* #__PURE__ */
  new TextDecoder() : typeof Buffer !== 'undefined' ? {
    decode: function decode(buf) {
      var out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
      return out.toString();
    }
  } : {
    decode: function decode(buf) {
      var out = '';

      for (var _i = 0; _i < buf.length; _i++) {
        out += String.fromCharCode(buf[_i]);
      }

      return out;
    }
  };

  var StringWriter =
  /*#__PURE__*/
  function () {
    function StringWriter() {
      _classCallCheck(this, StringWriter);

      this.pos = 0;
      this.out = '';
      this.buffer = new Uint8Array(bufLength);
    }

    _createClass(StringWriter, [{
      key: "write",
      value: function write(v) {
        var buffer = this.buffer;
        buffer[this.pos++] = v;

        if (this.pos === bufLength) {
          this.out += td.decode(buffer);
          this.pos = 0;
        }
      }
    }, {
      key: "flush",
      value: function flush() {
        var buffer = this.buffer,
            out = this.out,
            pos = this.pos;
        return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
      }
    }]);

    return StringWriter;
  }();

  var StringReader =
  /*#__PURE__*/
  function () {
    function StringReader(buffer) {
      _classCallCheck(this, StringReader);

      this.pos = 0;
      this.buffer = buffer;
    }

    _createClass(StringReader, [{
      key: "next",
      value: function next() {
        return this.buffer.charCodeAt(this.pos++);
      }
    }, {
      key: "peek",
      value: function peek() {
        return this.buffer.charCodeAt(this.pos);
      }
    }, {
      key: "indexOf",
      value: function indexOf(_char) {
        var buffer = this.buffer,
            pos = this.pos;
        var idx = buffer.indexOf(_char, pos);
        return idx === -1 ? buffer.length : idx;
      }
    }]);

    return StringReader;
  }();

  var EMPTY = [];

  function decodeOriginalScopes(input) {
    var length = input.length;
    var reader = new StringReader(input);
    var scopes = [];
    var stack = [];
    var line = 0;

    for (; reader.pos < length; reader.pos++) {
      line = decodeInteger(reader, line);
      var column = decodeInteger(reader, 0);

      if (!hasMoreVlq(reader, length)) {
        var last = stack.pop();
        last[2] = line;
        last[3] = column;
        continue;
      }

      var kind = decodeInteger(reader, 0);
      var fields = decodeInteger(reader, 0);
      var hasName = fields & 1;
      var scope = hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind];
      var vars = EMPTY;

      if (hasMoreVlq(reader, length)) {
        vars = [];

        do {
          var varsIndex = decodeInteger(reader, 0);
          vars.push(varsIndex);
        } while (hasMoreVlq(reader, length));
      }

      scope.vars = vars;
      scopes.push(scope);
      stack.push(scope);
    }

    return scopes;
  }

  function encodeOriginalScopes(scopes) {
    var writer = new StringWriter();

    for (var _i2 = 0; _i2 < scopes.length;) {
      _i2 = _encodeOriginalScopes(scopes, _i2, writer, [0]);
    }

    return writer.flush();
  }

  function _encodeOriginalScopes(scopes, index, writer, state) {
    var scope = scopes[index];
    var startLine = scope[0],
        startColumn = scope[1],
        endLine = scope[2],
        endColumn = scope[3],
        kind = scope[4],
        vars = scope.vars;
    if (index > 0) writer.write(comma);
    state[0] = encodeInteger(writer, startLine, state[0]);
    encodeInteger(writer, startColumn, 0);
    encodeInteger(writer, kind, 0);
    var fields = scope.length === 6 ? 1 : 0;
    encodeInteger(writer, fields, 0);
    if (scope.length === 6) encodeInteger(writer, scope[5], 0);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = vars[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var v = _step.value;
        encodeInteger(writer, v, 0);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    for (index++; index < scopes.length;) {
      var next = scopes[index];
      var l = next[0],
          _c2 = next[1];

      if (l > endLine || l === endLine && _c2 >= endColumn) {
        break;
      }

      index = _encodeOriginalScopes(scopes, index, writer, state);
    }

    writer.write(comma);
    state[0] = encodeInteger(writer, endLine, state[0]);
    encodeInteger(writer, endColumn, 0);
    return index;
  }

  function decodeGeneratedRanges(input) {
    var length = input.length;
    var reader = new StringReader(input);
    var ranges = [];
    var stack = [];
    var genLine = 0;
    var definitionSourcesIndex = 0;
    var definitionScopeIndex = 0;
    var callsiteSourcesIndex = 0;
    var callsiteLine = 0;
    var callsiteColumn = 0;
    var bindingLine = 0;
    var bindingColumn = 0;

    do {
      var semi = reader.indexOf(';');
      var genColumn = 0;

      for (; reader.pos < semi; reader.pos++) {
        genColumn = decodeInteger(reader, genColumn);

        if (!hasMoreVlq(reader, semi)) {
          var last = stack.pop();
          last[2] = genLine;
          last[3] = genColumn;
          continue;
        }

        var fields = decodeInteger(reader, 0);
        var hasDefinition = fields & 1;
        var hasCallsite = fields & 2;
        var hasScope = fields & 4;
        var callsite = null;
        var bindings = EMPTY;
        var range = void 0;

        if (hasDefinition) {
          var defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);
          definitionScopeIndex = decodeInteger(reader, definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0);
          definitionSourcesIndex = defSourcesIndex;
          range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];
        } else {
          range = [genLine, genColumn, 0, 0];
        }

        range.isScope = !!hasScope;

        if (hasCallsite) {
          var prevCsi = callsiteSourcesIndex;
          var prevLine = callsiteLine;
          callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);
          var sameSource = prevCsi === callsiteSourcesIndex;
          callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);
          callsiteColumn = decodeInteger(reader, sameSource && prevLine === callsiteLine ? callsiteColumn : 0);
          callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];
        }

        range.callsite = callsite;

        if (hasMoreVlq(reader, semi)) {
          bindings = [];

          do {
            bindingLine = genLine;
            bindingColumn = genColumn;
            var expressionsCount = decodeInteger(reader, 0);
            var expressionRanges = void 0;

            if (expressionsCount < -1) {
              expressionRanges = [[decodeInteger(reader, 0)]];

              for (var _i3 = -1; _i3 > expressionsCount; _i3--) {
                var prevBl = bindingLine;
                bindingLine = decodeInteger(reader, bindingLine);
                bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);
                var expression = decodeInteger(reader, 0);
                expressionRanges.push([expression, bindingLine, bindingColumn]);
              }
            } else {
              expressionRanges = [[expressionsCount]];
            }

            bindings.push(expressionRanges);
          } while (hasMoreVlq(reader, semi));
        }

        range.bindings = bindings;
        ranges.push(range);
        stack.push(range);
      }

      genLine++;
      reader.pos = semi + 1;
    } while (reader.pos < length);

    return ranges;
  }

  function encodeGeneratedRanges(ranges) {
    if (ranges.length === 0) return '';
    var writer = new StringWriter();

    for (var _i4 = 0; _i4 < ranges.length;) {
      _i4 = _encodeGeneratedRanges(ranges, _i4, writer, [0, 0, 0, 0, 0, 0, 0]);
    }

    return writer.flush();
  }

  function _encodeGeneratedRanges(ranges, index, writer, state) {
    var range = ranges[index];
    var startLine = range[0],
        startColumn = range[1],
        endLine = range[2],
        endColumn = range[3],
        isScope = range.isScope,
        callsite = range.callsite,
        bindings = range.bindings;

    if (state[0] < startLine) {
      catchupLine(writer, state[0], startLine);
      state[0] = startLine;
      state[1] = 0;
    } else if (index > 0) {
      writer.write(comma);
    }

    state[1] = encodeInteger(writer, range[1], state[1]);
    var fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);
    encodeInteger(writer, fields, 0);

    if (range.length === 6) {
      var sourcesIndex = range[4],
          scopesIndex = range[5];

      if (sourcesIndex !== state[2]) {
        state[3] = 0;
      }

      state[2] = encodeInteger(writer, sourcesIndex, state[2]);
      state[3] = encodeInteger(writer, scopesIndex, state[3]);
    }

    if (callsite) {
      var _range$callsite = range.callsite,
          _sourcesIndex = _range$callsite[0],
          callLine = _range$callsite[1],
          callColumn = _range$callsite[2];

      if (_sourcesIndex !== state[4]) {
        state[5] = 0;
        state[6] = 0;
      } else if (callLine !== state[5]) {
        state[6] = 0;
      }

      state[4] = encodeInteger(writer, _sourcesIndex, state[4]);
      state[5] = encodeInteger(writer, callLine, state[5]);
      state[6] = encodeInteger(writer, callColumn, state[6]);
    }

    if (bindings) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = bindings[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var binding = _step2.value;
          if (binding.length > 1) encodeInteger(writer, -binding.length, 0);
          var expression = binding[0][0];
          encodeInteger(writer, expression, 0);
          var bindingStartLine = startLine;
          var bindingStartColumn = startColumn;

          for (var _i5 = 1; _i5 < binding.length; _i5++) {
            var expRange = binding[_i5];
            bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);
            bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);
            encodeInteger(writer, expRange[0], 0);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    for (index++; index < ranges.length;) {
      var next = ranges[index];
      var l = next[0],
          _c3 = next[1];

      if (l > endLine || l === endLine && _c3 >= endColumn) {
        break;
      }

      index = _encodeGeneratedRanges(ranges, index, writer, state);
    }

    if (state[0] < endLine) {
      catchupLine(writer, state[0], endLine);
      state[0] = endLine;
      state[1] = 0;
    } else {
      writer.write(comma);
    }

    state[1] = encodeInteger(writer, endColumn, state[1]);
    return index;
  }

  function catchupLine(writer, lastLine, line) {
    do {
      writer.write(semicolon);
    } while (++lastLine < line);
  }

  function decode(mappings) {
    var length = mappings.length;
    var reader = new StringReader(mappings);
    var decoded = [];
    var genColumn = 0;
    var sourcesIndex = 0;
    var sourceLine = 0;
    var sourceColumn = 0;
    var namesIndex = 0;

    do {
      var semi = reader.indexOf(';');
      var line = [];
      var sorted = true;
      var lastCol = 0;
      genColumn = 0;

      while (reader.pos < semi) {
        var seg = void 0;
        genColumn = decodeInteger(reader, genColumn);
        if (genColumn < lastCol) sorted = false;
        lastCol = genColumn;

        if (hasMoreVlq(reader, semi)) {
          sourcesIndex = decodeInteger(reader, sourcesIndex);
          sourceLine = decodeInteger(reader, sourceLine);
          sourceColumn = decodeInteger(reader, sourceColumn);

          if (hasMoreVlq(reader, semi)) {
            namesIndex = decodeInteger(reader, namesIndex);
            seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
          } else {
            seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
          }
        } else {
          seg = [genColumn];
        }

        line.push(seg);
        reader.pos++;
      }

      if (!sorted) sort(line);
      decoded.push(line);
      reader.pos = semi + 1;
    } while (reader.pos <= length);

    return decoded;
  }

  function sort(line) {
    line.sort(sortComparator);
  }

  function sortComparator(a, b) {
    return a[0] - b[0];
  }

  function encode(decoded) {
    var writer = new StringWriter();
    var sourcesIndex = 0;
    var sourceLine = 0;
    var sourceColumn = 0;
    var namesIndex = 0;

    for (var _i6 = 0; _i6 < decoded.length; _i6++) {
      var line = decoded[_i6];
      if (_i6 > 0) writer.write(semicolon);
      if (line.length === 0) continue;
      var genColumn = 0;

      for (var j = 0; j < line.length; j++) {
        var segment = line[j];
        if (j > 0) writer.write(comma);
        genColumn = encodeInteger(writer, segment[0], genColumn);
        if (segment.length === 1) continue;
        sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
        sourceLine = encodeInteger(writer, segment[2], sourceLine);
        sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
        if (segment.length === 4) continue;
        namesIndex = encodeInteger(writer, segment[4], namesIndex);
      }
    }

    return writer.flush();
  }

  exports.decode = decode;
  exports.decodeGeneratedRanges = decodeGeneratedRanges;
  exports.decodeOriginalScopes = decodeOriginalScopes;
  exports.encode = encode;
  exports.encodeGeneratedRanges = encodeGeneratedRanges;
  exports.encodeOriginalScopes = encodeOriginalScopes;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});