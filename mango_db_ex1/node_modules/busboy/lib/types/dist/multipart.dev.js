'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('stream'),
    Readable = _require.Readable,
    Writable = _require.Writable;

var StreamSearch = require('streamsearch');

var _require2 = require('../utils.js'),
    basename = _require2.basename,
    convertToUTF8 = _require2.convertToUTF8,
    getDecoder = _require2.getDecoder,
    parseContentType = _require2.parseContentType,
    parseDisposition = _require2.parseDisposition;

var BUF_CRLF = Buffer.from('\r\n');
var BUF_CR = Buffer.from('\r');
var BUF_DASH = Buffer.from('-');

function noop() {}

var MAX_HEADER_PAIRS = 2000; // From node

var MAX_HEADER_SIZE = 16 * 1024; // From node (its default value)

var HPARSER_NAME = 0;
var HPARSER_PRE_OWS = 1;
var HPARSER_VALUE = 2;

var HeaderParser =
/*#__PURE__*/
function () {
  function HeaderParser(cb) {
    _classCallCheck(this, HeaderParser);

    this.header = Object.create(null);
    this.pairCount = 0;
    this.byteCount = 0;
    this.state = HPARSER_NAME;
    this.name = '';
    this.value = '';
    this.crlf = 0;
    this.cb = cb;
  }

  _createClass(HeaderParser, [{
    key: "reset",
    value: function reset() {
      this.header = Object.create(null);
      this.pairCount = 0;
      this.byteCount = 0;
      this.state = HPARSER_NAME;
      this.name = '';
      this.value = '';
      this.crlf = 0;
    }
  }, {
    key: "push",
    value: function push(chunk, pos, end) {
      var start = pos;

      while (pos < end) {
        switch (this.state) {
          case HPARSER_NAME:
            {
              var done = false;

              for (; pos < end; ++pos) {
                if (this.byteCount === MAX_HEADER_SIZE) return -1;
                ++this.byteCount;
                var code = chunk[pos];

                if (TOKEN[code] !== 1) {
                  if (code !== 58
                  /* ':' */
                  ) return -1;
                  this.name += chunk.latin1Slice(start, pos);
                  if (this.name.length === 0) return -1;
                  ++pos;
                  done = true;
                  this.state = HPARSER_PRE_OWS;
                  break;
                }
              }

              if (!done) {
                this.name += chunk.latin1Slice(start, pos);
                break;
              } // FALLTHROUGH

            }

          case HPARSER_PRE_OWS:
            {
              // Skip optional whitespace
              var _done = false;

              for (; pos < end; ++pos) {
                if (this.byteCount === MAX_HEADER_SIZE) return -1;
                ++this.byteCount;
                var _code = chunk[pos];

                if (_code !== 32
                /* ' ' */
                && _code !== 9
                /* '\t' */
                ) {
                    start = pos;
                    _done = true;
                    this.state = HPARSER_VALUE;
                    break;
                  }
              }

              if (!_done) break; // FALLTHROUGH
            }

          case HPARSER_VALUE:
            switch (this.crlf) {
              case 0:
                // Nothing yet
                for (; pos < end; ++pos) {
                  if (this.byteCount === MAX_HEADER_SIZE) return -1;
                  ++this.byteCount;
                  var _code2 = chunk[pos];

                  if (FIELD_VCHAR[_code2] !== 1) {
                    if (_code2 !== 13
                    /* '\r' */
                    ) return -1;
                    ++this.crlf;
                    break;
                  }
                }

                this.value += chunk.latin1Slice(start, pos++);
                break;

              case 1:
                // Received CR
                if (this.byteCount === MAX_HEADER_SIZE) return -1;
                ++this.byteCount;
                if (chunk[pos++] !== 10
                /* '\n' */
                ) return -1;
                ++this.crlf;
                break;

              case 2:
                {
                  // Received CR LF
                  if (this.byteCount === MAX_HEADER_SIZE) return -1;
                  ++this.byteCount;
                  var _code3 = chunk[pos];

                  if (_code3 === 32
                  /* ' ' */
                  || _code3 === 9
                  /* '\t' */
                  ) {
                      // Folded value
                      start = pos;
                      this.crlf = 0;
                    } else {
                    if (++this.pairCount < MAX_HEADER_PAIRS) {
                      this.name = this.name.toLowerCase();
                      if (this.header[this.name] === undefined) this.header[this.name] = [this.value];else this.header[this.name].push(this.value);
                    }

                    if (_code3 === 13
                    /* '\r' */
                    ) {
                        ++this.crlf;
                        ++pos;
                      } else {
                      // Assume start of next header field name
                      start = pos;
                      this.crlf = 0;
                      this.state = HPARSER_NAME;
                      this.name = '';
                      this.value = '';
                    }
                  }

                  break;
                }

              case 3:
                {
                  // Received CR LF CR
                  if (this.byteCount === MAX_HEADER_SIZE) return -1;
                  ++this.byteCount;
                  if (chunk[pos++] !== 10
                  /* '\n' */
                  ) return -1; // End of header

                  var header = this.header;
                  this.reset();
                  this.cb(header);
                  return pos;
                }
            }

            break;
        }
      }

      return pos;
    }
  }]);

  return HeaderParser;
}();

var FileStream =
/*#__PURE__*/
function (_Readable) {
  _inherits(FileStream, _Readable);

  function FileStream(opts, owner) {
    var _this;

    _classCallCheck(this, FileStream);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(FileStream).call(this, opts));
    _this.truncated = false;
    _this._readcb = null;

    _this.once('end', function () {
      // We need to make sure that we call any outstanding _writecb() that is
      // associated with this file so that processing of the rest of the form
      // can continue. This may not happen if the file stream ends right after
      // backpressure kicks in, so we force it here.
      _this._read();

      if (--owner._fileEndsLeft === 0 && owner._finalcb) {
        var cb = owner._finalcb;
        owner._finalcb = null; // Make sure other 'end' event handlers get a chance to be executed
        // before busboy's 'finish' event is emitted

        process.nextTick(cb);
      }
    });

    return _this;
  }

  _createClass(FileStream, [{
    key: "_read",
    value: function _read(n) {
      var cb = this._readcb;

      if (cb) {
        this._readcb = null;
        cb();
      }
    }
  }]);

  return FileStream;
}(Readable);

var ignoreData = {
  push: function push(chunk, pos) {},
  destroy: function destroy() {}
};

function callAndUnsetCb(self, err) {
  var cb = self._writecb;
  self._writecb = null;
  if (err) self.destroy(err);else if (cb) cb();
}

function nullDecoder(val, hint) {
  return val;
}

var Multipart =
/*#__PURE__*/
function (_Writable) {
  _inherits(Multipart, _Writable);

  function Multipart(cfg) {
    var _this2;

    _classCallCheck(this, Multipart);

    var streamOpts = {
      autoDestroy: true,
      emitClose: true,
      highWaterMark: typeof cfg.highWaterMark === 'number' ? cfg.highWaterMark : undefined
    };
    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Multipart).call(this, streamOpts));
    if (!cfg.conType.params || typeof cfg.conType.params.boundary !== 'string') throw new Error('Multipart: Boundary not found');
    var boundary = cfg.conType.params.boundary;
    var paramDecoder = typeof cfg.defParamCharset === 'string' && cfg.defParamCharset ? getDecoder(cfg.defParamCharset) : nullDecoder;
    var defCharset = cfg.defCharset || 'utf8';
    var preservePath = cfg.preservePath;
    var fileOpts = {
      autoDestroy: true,
      emitClose: true,
      highWaterMark: typeof cfg.fileHwm === 'number' ? cfg.fileHwm : undefined
    };
    var limits = cfg.limits;
    var fieldSizeLimit = limits && typeof limits.fieldSize === 'number' ? limits.fieldSize : 1 * 1024 * 1024;
    var fileSizeLimit = limits && typeof limits.fileSize === 'number' ? limits.fileSize : Infinity;
    var filesLimit = limits && typeof limits.files === 'number' ? limits.files : Infinity;
    var fieldsLimit = limits && typeof limits.fields === 'number' ? limits.fields : Infinity;
    var partsLimit = limits && typeof limits.parts === 'number' ? limits.parts : Infinity;
    var parts = -1; // Account for initial boundary

    var fields = 0;
    var files = 0;
    var skipPart = false;
    _this2._fileEndsLeft = 0;
    _this2._fileStream = undefined;
    _this2._complete = false;
    var fileSize = 0;
    var field;
    var fieldSize = 0;
    var partCharset;
    var partEncoding;
    var partType;
    var partName;
    var partTruncated = false;
    var hitFilesLimit = false;
    var hitFieldsLimit = false;
    _this2._hparser = null;
    var hparser = new HeaderParser(function (header) {
      _this2._hparser = null;
      skipPart = false;
      partType = 'text/plain';
      partCharset = defCharset;
      partEncoding = '7bit';
      partName = undefined;
      partTruncated = false;
      var filename;

      if (!header['content-disposition']) {
        skipPart = true;
        return;
      }

      var disp = parseDisposition(header['content-disposition'][0], paramDecoder);

      if (!disp || disp.type !== 'form-data') {
        skipPart = true;
        return;
      }

      if (disp.params) {
        if (disp.params.name) partName = disp.params.name;
        if (disp.params['filename*']) filename = disp.params['filename*'];else if (disp.params.filename) filename = disp.params.filename;
        if (filename !== undefined && !preservePath) filename = basename(filename);
      }

      if (header['content-type']) {
        var conType = parseContentType(header['content-type'][0]);

        if (conType) {
          partType = "".concat(conType.type, "/").concat(conType.subtype);
          if (conType.params && typeof conType.params.charset === 'string') partCharset = conType.params.charset.toLowerCase();
        }
      }

      if (header['content-transfer-encoding']) partEncoding = header['content-transfer-encoding'][0].toLowerCase();

      if (partType === 'application/octet-stream' || filename !== undefined) {
        // File
        if (files === filesLimit) {
          if (!hitFilesLimit) {
            hitFilesLimit = true;

            _this2.emit('filesLimit');
          }

          skipPart = true;
          return;
        }

        ++files;

        if (_this2.listenerCount('file') === 0) {
          skipPart = true;
          return;
        }

        fileSize = 0;
        _this2._fileStream = new FileStream(fileOpts, _assertThisInitialized(_this2));
        ++_this2._fileEndsLeft;

        _this2.emit('file', partName, _this2._fileStream, {
          filename: filename,
          encoding: partEncoding,
          mimeType: partType
        });
      } else {
        // Non-file
        if (fields === fieldsLimit) {
          if (!hitFieldsLimit) {
            hitFieldsLimit = true;

            _this2.emit('fieldsLimit');
          }

          skipPart = true;
          return;
        }

        ++fields;

        if (_this2.listenerCount('field') === 0) {
          skipPart = true;
          return;
        }

        field = [];
        fieldSize = 0;
      }
    });
    var matchPostBoundary = 0;

    var ssCb = function ssCb(isMatch, data, start, end, isDataSafe) {
      retrydata: while (data) {
        if (_this2._hparser !== null) {
          var ret = _this2._hparser.push(data, start, end);

          if (ret === -1) {
            _this2._hparser = null;
            hparser.reset();

            _this2.emit('error', new Error('Malformed part header'));

            break;
          }

          start = ret;
        }

        if (start === end) break;

        if (matchPostBoundary !== 0) {
          if (matchPostBoundary === 1) {
            switch (data[start]) {
              case 45:
                // '-'
                // Try matching '--' after boundary
                matchPostBoundary = 2;
                ++start;
                break;

              case 13:
                // '\r'
                // Try matching CR LF before header
                matchPostBoundary = 3;
                ++start;
                break;

              default:
                matchPostBoundary = 0;
            }

            if (start === end) return;
          }

          if (matchPostBoundary === 2) {
            matchPostBoundary = 0;

            if (data[start] === 45
            /* '-' */
            ) {
                // End of multipart data
                _this2._complete = true;
                _this2._bparser = ignoreData;
                return;
              } // We saw something other than '-', so put the dash we consumed
            // "back"


            var writecb = _this2._writecb;
            _this2._writecb = noop;
            ssCb(false, BUF_DASH, 0, 1, false);
            _this2._writecb = writecb;
          } else if (matchPostBoundary === 3) {
            matchPostBoundary = 0;

            if (data[start] === 10
            /* '\n' */
            ) {
                ++start;
                if (parts >= partsLimit) break; // Prepare the header parser

                _this2._hparser = hparser;
                if (start === end) break; // Process the remaining data as a header

                continue retrydata;
              } else {
              // We saw something other than LF, so put the CR we consumed
              // "back"
              var _writecb = _this2._writecb;
              _this2._writecb = noop;
              ssCb(false, BUF_CR, 0, 1, false);
              _this2._writecb = _writecb;
            }
          }
        }

        if (!skipPart) {
          if (_this2._fileStream) {
            var chunk = void 0;
            var actualLen = Math.min(end - start, fileSizeLimit - fileSize);

            if (!isDataSafe) {
              chunk = Buffer.allocUnsafe(actualLen);
              data.copy(chunk, 0, start, start + actualLen);
            } else {
              chunk = data.slice(start, start + actualLen);
            }

            fileSize += chunk.length;

            if (fileSize === fileSizeLimit) {
              if (chunk.length > 0) _this2._fileStream.push(chunk);

              _this2._fileStream.emit('limit');

              _this2._fileStream.truncated = true;
              skipPart = true;
            } else if (!_this2._fileStream.push(chunk)) {
              if (_this2._writecb) _this2._fileStream._readcb = _this2._writecb;
              _this2._writecb = null;
            }
          } else if (field !== undefined) {
            var _chunk = void 0;

            var _actualLen = Math.min(end - start, fieldSizeLimit - fieldSize);

            if (!isDataSafe) {
              _chunk = Buffer.allocUnsafe(_actualLen);
              data.copy(_chunk, 0, start, start + _actualLen);
            } else {
              _chunk = data.slice(start, start + _actualLen);
            }

            fieldSize += _actualLen;
            field.push(_chunk);

            if (fieldSize === fieldSizeLimit) {
              skipPart = true;
              partTruncated = true;
            }
          }
        }

        break;
      }

      if (isMatch) {
        matchPostBoundary = 1;

        if (_this2._fileStream) {
          // End the active file stream if the previous part was a file
          _this2._fileStream.push(null);

          _this2._fileStream = null;
        } else if (field !== undefined) {
          var _data;

          switch (field.length) {
            case 0:
              _data = '';
              break;

            case 1:
              _data = convertToUTF8(field[0], partCharset, 0);
              break;

            default:
              _data = convertToUTF8(Buffer.concat(field, fieldSize), partCharset, 0);
          }

          field = undefined;
          fieldSize = 0;

          _this2.emit('field', partName, _data, {
            nameTruncated: false,
            valueTruncated: partTruncated,
            encoding: partEncoding,
            mimeType: partType
          });
        }

        if (++parts === partsLimit) _this2.emit('partsLimit');
      }
    };

    _this2._bparser = new StreamSearch("\r\n--".concat(boundary), ssCb);
    _this2._writecb = null;
    _this2._finalcb = null; // Just in case there is no preamble

    _this2.write(BUF_CRLF);

    return _this2;
  }

  _createClass(Multipart, [{
    key: "_write",
    value: function _write(chunk, enc, cb) {
      this._writecb = cb;

      this._bparser.push(chunk, 0);

      if (this._writecb) callAndUnsetCb(this);
    }
  }, {
    key: "_destroy",
    value: function _destroy(err, cb) {
      this._hparser = null;
      this._bparser = ignoreData;
      if (!err) err = checkEndState(this);
      var fileStream = this._fileStream;

      if (fileStream) {
        this._fileStream = null;
        fileStream.destroy(err);
      }

      cb(err);
    }
  }, {
    key: "_final",
    value: function _final(cb) {
      this._bparser.destroy();

      if (!this._complete) return cb(new Error('Unexpected end of form'));
      if (this._fileEndsLeft) this._finalcb = finalcb.bind(null, this, cb);else finalcb(this, cb);
    }
  }], [{
    key: "detect",
    value: function detect(conType) {
      return conType.type === 'multipart' && conType.subtype === 'form-data';
    }
  }]);

  return Multipart;
}(Writable);

function finalcb(self, cb, err) {
  if (err) return cb(err);
  err = checkEndState(self);
  cb(err);
}

function checkEndState(self) {
  if (self._hparser) return new Error('Malformed part header');
  var fileStream = self._fileStream;

  if (fileStream) {
    self._fileStream = null;
    fileStream.destroy(new Error('Unexpected end of file'));
  }

  if (!self._complete) return new Error('Unexpected end of form');
}

var TOKEN = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
var FIELD_VCHAR = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
module.exports = Multipart;