'use strict';

function createMultipartBuffers(boundary, sizes) {
  var bufs = [];

  for (var i = 0; i < sizes.length; ++i) {
    var mb = sizes[i] * 1024 * 1024;
    bufs.push(Buffer.from(["--".concat(boundary), "content-disposition: form-data; name=\"file".concat(i + 1, "\"; ") + "filename=\"random".concat(i + 1, ".bin\""), 'content-type: application/octet-stream', '', '0'.repeat(mb), ''].join('\r\n')));
  }

  bufs.push(Buffer.from(["--".concat(boundary, "--"), ''].join('\r\n')));
  return bufs;
}

var boundary = '-----------------------------168072824752491622650073';
var buffers = createMultipartBuffers(boundary, [10, 10, 10, 20, 50]);
var calls = {
  partBegin: 0,
  headerField: 0,
  headerValue: 0,
  headerEnd: 0,
  headersEnd: 0,
  partData: 0,
  partEnd: 0,
  end: 0
};
var moduleName = process.argv[2];

switch (moduleName) {
  case 'busboy':
    {
      var busboy = require('busboy');

      var parser = busboy({
        limits: {
          fieldSizeLimit: Infinity
        },
        headers: {
          'content-type': "multipart/form-data; boundary=".concat(boundary)
        }
      });
      parser.on('file', function (name, stream, info) {
        ++calls.partBegin;
        stream.on('data', function (chunk) {
          ++calls.partData;
        }).on('end', function () {
          ++calls.partEnd;
        });
      }).on('close', function () {
        ++calls.end;
        console.timeEnd(moduleName);
      });
      console.time(moduleName);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = buffers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var buf = _step.value;
          parser.write(buf);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      break;
    }

  case 'formidable':
    {
      var _require = require('formidable'),
          MultipartParser = _require.MultipartParser;

      var _parser = new MultipartParser();

      _parser.initWithBoundary(boundary);

      _parser.on('data', function (_ref) {
        var name = _ref.name;
        ++calls[name];
        if (name === 'end') console.timeEnd(moduleName);
      });

      console.time(moduleName);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = buffers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _buf = _step2.value;

          _parser.write(_buf);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      break;
    }

  case 'multiparty':
    {
      var hijack = function hijack(name, fn) {
        var oldFn = form[name];

        form[name] = function () {
          fn();
          return oldFn.apply(this, arguments);
        };
      };

      var _require2 = require('stream'),
          Readable = _require2.Readable;

      var _require3 = require('multiparty'),
          Form = _require3.Form;

      var form = new Form({
        maxFieldsSize: Infinity,
        maxFields: Infinity,
        maxFilesSize: Infinity,
        autoFields: false,
        autoFiles: false
      });
      var req = new Readable({
        read: function read() {}
      });
      req.headers = {
        'content-type': "multipart/form-data; boundary=".concat(boundary)
      };
      hijack('onParseHeaderField', function () {
        ++calls.headerField;
      });
      hijack('onParseHeaderValue', function () {
        ++calls.headerValue;
      });
      hijack('onParsePartBegin', function () {
        ++calls.partBegin;
      });
      hijack('onParsePartData', function () {
        ++calls.partData;
      });
      hijack('onParsePartEnd', function () {
        ++calls.partEnd;
      });
      form.on('close', function () {
        ++calls.end;
        console.timeEnd(moduleName);
      }).on('part', function (p) {
        return p.resume();
      });
      console.time(moduleName);
      form.parse(req);
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = buffers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _buf2 = _step3.value;
          req.push(_buf2);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      req.push(null);
      break;
    }

  default:
    if (moduleName === undefined) console.error('Missing parser module name');else console.error("Invalid parser module name: ".concat(moduleName));
    process.exit(1);
}