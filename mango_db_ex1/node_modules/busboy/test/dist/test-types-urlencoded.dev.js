'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var assert = require('assert');

var _require = require('buffer'),
    transcode = _require.transcode;

var _require2 = require('util'),
    inspect = _require2.inspect;

var busboy = require('..');

var active = new Map();
var tests = [{
  source: ['foo'],
  expected: [['foo', '', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }]],
  what: 'Unassigned value'
}, {
  source: ['foo=bar'],
  expected: [['foo', 'bar', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }]],
  what: 'Assigned value'
}, {
  source: ['foo&bar=baz'],
  expected: [['foo', '', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }], ['bar', 'baz', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }]],
  what: 'Unassigned and assigned value'
}, {
  source: ['foo=bar&baz'],
  expected: [['foo', 'bar', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }], ['baz', '', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }]],
  what: 'Assigned and unassigned value'
}, {
  source: ['foo=bar&baz=bla'],
  expected: [['foo', 'bar', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }], ['baz', 'bla', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }]],
  what: 'Two assigned values'
}, {
  source: ['foo&bar'],
  expected: [['foo', '', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }], ['bar', '', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }]],
  what: 'Two unassigned values'
}, {
  source: ['foo&bar&'],
  expected: [['foo', '', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }], ['bar', '', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }]],
  what: 'Two unassigned values and ampersand'
}, {
  source: ['foo+1=bar+baz%2Bquux'],
  expected: [['foo 1', 'bar baz+quux', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }]],
  what: 'Assigned key and value with (plus) space'
}, {
  source: ['foo=bar%20baz%21'],
  expected: [['foo', 'bar baz!', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }]],
  what: 'Assigned value with encoded bytes'
}, {
  source: ['foo%20bar=baz%20bla%21'],
  expected: [['foo bar', 'baz bla!', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }]],
  what: 'Assigned value with encoded bytes #2'
}, {
  source: ['foo=bar%20baz%21&num=1000'],
  expected: [['foo', 'bar baz!', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }], ['num', '1000', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }]],
  what: 'Two assigned values, one with encoded bytes'
}, {
  source: [Array.from(transcode(Buffer.from('foo'), 'utf8', 'utf16le')).map(function (n) {
    return "%".concat(n.toString(16).padStart(2, '0'));
  }).join(''), '=', Array.from(transcode(Buffer.from('ðŸ˜€!'), 'utf8', 'utf16le')).map(function (n) {
    return "%".concat(n.toString(16).padStart(2, '0'));
  }).join('')],
  expected: [['foo', 'ðŸ˜€!', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'UTF-16LE',
    mimeType: 'text/plain'
  }]],
  charset: 'UTF-16LE',
  what: 'Encoded value with multi-byte charset'
}, {
  source: ['foo=<', Array.from(transcode(Buffer.from('Â©:^Ã¾'), 'utf8', 'latin1')).map(function (n) {
    return "%".concat(n.toString(16).padStart(2, '0'));
  }).join('')],
  expected: [['foo', '<Â©:^Ã¾', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'ISO-8859-1',
    mimeType: 'text/plain'
  }]],
  charset: 'ISO-8859-1',
  what: 'Encoded value with single-byte, ASCII-compatible, non-UTF8 charset'
}, {
  source: ['foo=bar&baz=bla'],
  expected: [],
  what: 'Limits: zero fields',
  limits: {
    fields: 0
  }
}, {
  source: ['foo=bar&baz=bla'],
  expected: [['foo', 'bar', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }]],
  what: 'Limits: one field',
  limits: {
    fields: 1
  }
}, {
  source: ['foo=bar&baz=bla'],
  expected: [['foo', 'bar', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }], ['baz', 'bla', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }]],
  what: 'Limits: field part lengths match limits',
  limits: {
    fieldNameSize: 3,
    fieldSize: 3
  }
}, {
  source: ['foo=bar&baz=bla'],
  expected: [['fo', 'bar', {
    nameTruncated: true,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }], ['ba', 'bla', {
    nameTruncated: true,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }]],
  what: 'Limits: truncated field name',
  limits: {
    fieldNameSize: 2
  }
}, {
  source: ['foo=bar&baz=bla'],
  expected: [['foo', 'ba', {
    nameTruncated: false,
    valueTruncated: true,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }], ['baz', 'bl', {
    nameTruncated: false,
    valueTruncated: true,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }]],
  what: 'Limits: truncated field value',
  limits: {
    fieldSize: 2
  }
}, {
  source: ['foo=bar&baz=bla'],
  expected: [['fo', 'ba', {
    nameTruncated: true,
    valueTruncated: true,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }], ['ba', 'bl', {
    nameTruncated: true,
    valueTruncated: true,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }]],
  what: 'Limits: truncated field name and value',
  limits: {
    fieldNameSize: 2,
    fieldSize: 2
  }
}, {
  source: ['foo=bar&baz=bla'],
  expected: [['fo', '', {
    nameTruncated: true,
    valueTruncated: true,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }], ['ba', '', {
    nameTruncated: true,
    valueTruncated: true,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }]],
  what: 'Limits: truncated field name and zero value limit',
  limits: {
    fieldNameSize: 2,
    fieldSize: 0
  }
}, {
  source: ['foo=bar&baz=bla'],
  expected: [['', '', {
    nameTruncated: true,
    valueTruncated: true,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }], ['', '', {
    nameTruncated: true,
    valueTruncated: true,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }]],
  what: 'Limits: truncated zero field name and zero value limit',
  limits: {
    fieldNameSize: 0,
    fieldSize: 0
  }
}, {
  source: ['&'],
  expected: [],
  what: 'Ampersand'
}, {
  source: ['&&&&&'],
  expected: [],
  what: 'Many ampersands'
}, {
  source: ['='],
  expected: [['', '', {
    nameTruncated: false,
    valueTruncated: false,
    encoding: 'utf-8',
    mimeType: 'text/plain'
  }]],
  what: 'Assigned value, empty name and value'
}, {
  source: [''],
  expected: [],
  what: 'Nothing'
}];

var _loop = function _loop() {
  var test = _tests[_i];
  active.set(test, 1);
  var what = test.what;
  var charset = test.charset || 'utf-8';
  var bb = busboy({
    limits: test.limits,
    headers: {
      'content-type': "application/x-www-form-urlencoded; charset=".concat(charset)
    }
  });
  var results = [];
  bb.on('field', function (key, val, info) {
    results.push([key, val, info]);
  });
  bb.on('file', function () {
    throw new Error("[".concat(what, "] Unexpected file"));
  });
  bb.on('close', function () {
    active["delete"](test);
    assert.deepStrictEqual(results, test.expected, "[".concat(what, "] Results mismatch.\n") + "Parsed: ".concat(inspect(results), "\n") + "Expected: ".concat(inspect(test.expected)));
  });
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = test.source[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var src = _step.value;
      var buf = typeof src === 'string' ? Buffer.from(src, 'utf8') : src;
      bb.write(buf);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  bb.end();
};

for (var _i = 0, _tests = tests; _i < _tests.length; _i++) {
  _loop();
} // Byte-by-byte versions


var _loop2 = function _loop2() {
  var test = _tests2[_i2];
  test = _objectSpread({}, test);
  test.what += ' (byte-by-byte)';
  active.set(test, 1);
  var _test = test,
      what = _test.what;
  var charset = test.charset || 'utf-8';
  var bb = busboy({
    limits: test.limits,
    headers: {
      'content-type': "application/x-www-form-urlencoded; charset=\"".concat(charset, "\"")
    }
  });
  var results = [];
  bb.on('field', function (key, val, info) {
    results.push([key, val, info]);
  });
  bb.on('file', function () {
    throw new Error("[".concat(what, "] Unexpected file"));
  });
  bb.on('close', function () {
    active["delete"](test);
    assert.deepStrictEqual(results, test.expected, "[".concat(what, "] Results mismatch.\n") + "Parsed: ".concat(inspect(results), "\n") + "Expected: ".concat(inspect(test.expected)));
  });
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = test.source[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var src = _step2.value;
      var buf = typeof src === 'string' ? Buffer.from(src, 'utf8') : src;

      for (var i = 0; i < buf.length; ++i) {
        bb.write(buf.slice(i, i + 1));
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  bb.end();
};

for (var _i2 = 0, _tests2 = tests; _i2 < _tests2.length; _i2++) {
  _loop2();
}

{
  var exception = false;
  process.once('uncaughtException', function (ex) {
    exception = true;
    throw ex;
  });
  process.on('exit', function () {
    if (exception || active.size === 0) return;
    process.exitCode = 1;
    console.error('==========================');
    console.error("".concat(active.size, " test(s) did not finish:"));
    console.error('==========================');
    console.error(Array.from(active.keys()).map(function (v) {
      return v.what;
    }).join('\n'));
  });
}