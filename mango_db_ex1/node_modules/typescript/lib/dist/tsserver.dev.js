/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;

var __copyProps = function __copyProps(to, from, except, desc) {
  if (from && _typeof(from) === "object" || typeof from === "function") {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      var _loop = function _loop() {
        var key = _step.value;
        if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
          get: function get() {
            return from[key];
          },
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
      };

      for (var _iterator = __getOwnPropNames(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        _loop();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return to;
};

var __reExport = function __reExport(target, mod, secondTarget) {
  return __copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default");
};

var __toESM = function __toESM(mod, isNodeMode, target) {
  return target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps( // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
    value: mod,
    enumerable: true
  }) : target, mod);
}; // src/tsserver/server.ts


var import_os2 = __toESM(require("os")); // src/typescript/typescript.ts


var typescript_exports = {};

__reExport(typescript_exports, require("./typescript.js")); // src/tsserver/nodeServer.ts


var import_child_process = __toESM(require("child_process"));

var import_fs = __toESM(require("fs"));

var import_net = __toESM(require("net"));

var import_os = __toESM(require("os"));

var import_readline = __toESM(require("readline")); // src/tsserver/common.ts


function getLogLevel(level) {
  if (level) {
    var l = level.toLowerCase();

    for (var name in typescript_exports.server.LogLevel) {
      if (isNaN(+name) && l === name.toLowerCase()) {
        return typescript_exports.server.LogLevel[name];
      }
    }
  }

  return void 0;
} // src/tsserver/nodeServer.ts


function parseLoggingEnvironmentString(logEnvStr) {
  if (!logEnvStr) {
    return {};
  }

  var logEnv = {
    logToFile: true
  };
  var args = logEnvStr.split(" ");
  var len = args.length - 1;

  for (var i = 0; i < len; i += 2) {
    var option = args[i];

    var _getEntireValue = getEntireValue(i + 1),
        value = _getEntireValue.value,
        extraPartCounter = _getEntireValue.extraPartCounter;

    i += extraPartCounter;

    if (option && value) {
      switch (option) {
        case "-file":
          logEnv.file = value;
          break;

        case "-level":
          var level = getLogLevel(value);
          logEnv.detailLevel = level !== void 0 ? level : typescript_exports.server.LogLevel.normal;
          break;

        case "-traceToConsole":
          logEnv.traceToConsole = value.toLowerCase() === "true";
          break;

        case "-logToFile":
          logEnv.logToFile = value.toLowerCase() === "true";
          break;
      }
    }
  }

  return logEnv;

  function getEntireValue(initialIndex) {
    var pathStart = args[initialIndex];
    var extraPartCounter = 0;

    if (pathStart.charCodeAt(0) === typescript_exports.CharacterCodes.doubleQuote && pathStart.charCodeAt(pathStart.length - 1) !== typescript_exports.CharacterCodes.doubleQuote) {
      for (var _i = initialIndex + 1; _i < args.length; _i++) {
        pathStart += " ";
        pathStart += args[_i];
        extraPartCounter++;
        if (pathStart.charCodeAt(pathStart.length - 1) === typescript_exports.CharacterCodes.doubleQuote) break;
      }
    }

    return {
      value: (0, typescript_exports.stripQuotes)(pathStart),
      extraPartCounter: extraPartCounter
    };
  }
}

function parseServerMode() {
  var mode = typescript_exports.server.findArgument("--serverMode");
  if (!mode) return void 0;

  switch (mode.toLowerCase()) {
    case "semantic":
      return typescript_exports.LanguageServiceMode.Semantic;

    case "partialsemantic":
      return typescript_exports.LanguageServiceMode.PartialSemantic;

    case "syntactic":
      return typescript_exports.LanguageServiceMode.Syntactic;

    default:
      return mode;
  }
}

function initializeNodeSystem() {
  var sys4 = typescript_exports.Debug.checkDefined(typescript_exports.sys);

  var Logger =
  /*#__PURE__*/
  function () {
    function Logger(logFilename, traceToConsole, level) {
      _classCallCheck(this, Logger);

      this.logFilename = logFilename;
      this.traceToConsole = traceToConsole;
      this.level = level;
      this.seq = 0;
      this.inGroup = false;
      this.firstInGroup = true;
      this.fd = -1;

      if (this.logFilename) {
        try {
          this.fd = import_fs["default"].openSync(this.logFilename, "w");
        } catch (_unused) {}
      }
    }

    _createClass(Logger, [{
      key: "close",
      value: function close() {
        if (this.fd >= 0) {
          import_fs["default"].close(this.fd, typescript_exports.noop);
        }
      }
    }, {
      key: "getLogFileName",
      value: function getLogFileName() {
        return this.logFilename;
      }
    }, {
      key: "perftrc",
      value: function perftrc(s) {
        this.msg(s, typescript_exports.server.Msg.Perf);
      }
    }, {
      key: "info",
      value: function info(s) {
        this.msg(s, typescript_exports.server.Msg.Info);
      }
    }, {
      key: "err",
      value: function err(s) {
        this.msg(s, typescript_exports.server.Msg.Err);
      }
    }, {
      key: "startGroup",
      value: function startGroup() {
        this.inGroup = true;
        this.firstInGroup = true;
      }
    }, {
      key: "endGroup",
      value: function endGroup() {
        this.inGroup = false;
      }
    }, {
      key: "loggingEnabled",
      value: function loggingEnabled() {
        return !!this.logFilename || this.traceToConsole;
      }
    }, {
      key: "hasLevel",
      value: function hasLevel(level) {
        return this.loggingEnabled() && this.level >= level;
      }
    }, {
      key: "msg",
      value: function msg(s) {
        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : typescript_exports.server.Msg.Err;
        if (!this.canWrite()) return;
        s = "[".concat(typescript_exports.server.nowString(), "] ").concat(s, "\n");

        if (!this.inGroup || this.firstInGroup) {
          var prefix = Logger.padStringRight(type + " " + this.seq.toString(), "          ");
          s = prefix + s;
        }

        this.write(s, type);

        if (!this.inGroup) {
          this.seq++;
        }
      }
    }, {
      key: "canWrite",
      value: function canWrite() {
        return this.fd >= 0 || this.traceToConsole;
      }
    }, {
      key: "write",
      value: function write(s, _type) {
        if (this.fd >= 0) {
          var buf = Buffer.from(s);
          import_fs["default"].writeSync(this.fd, buf, 0, buf.length,
          /*position*/
          null);
        }

        if (this.traceToConsole) {
          console.warn(s);
        }
      }
    }], [{
      key: "padStringRight",
      value: function padStringRight(str, padding) {
        return (str + padding).slice(0, padding.length);
      }
    }]);

    return Logger;
  }();

  var libDirectory = (0, typescript_exports.getDirectoryPath)((0, typescript_exports.normalizePath)(sys4.getExecutingFilePath()));
  var useWatchGuard = process.platform === "win32";
  var originalWatchDirectory = sys4.watchDirectory.bind(sys4);
  var logger = createLogger();
  typescript_exports.Debug.loggingHost = {
    log: function log(level, s) {
      switch (level) {
        case typescript_exports.LogLevel.Error:
        case typescript_exports.LogLevel.Warning:
          return logger.msg(s, typescript_exports.server.Msg.Err);

        case typescript_exports.LogLevel.Info:
        case typescript_exports.LogLevel.Verbose:
          return logger.msg(s, typescript_exports.server.Msg.Info);
      }
    }
  };
  var pending = (0, typescript_exports.createQueue)();
  var canWrite = true;

  if (useWatchGuard) {
    var currentDrive = extractWatchDirectoryCacheKey(sys4.resolvePath(sys4.getCurrentDirectory()),
    /*currentDriveKey*/
    void 0);
    var statusCache =
    /* @__PURE__ */
    new Map();

    sys4.watchDirectory = function (path, callback, recursive, options) {
      var cacheKey = extractWatchDirectoryCacheKey(path, currentDrive);
      var status = cacheKey && statusCache.get(cacheKey);

      if (status === void 0) {
        if (logger.hasLevel(typescript_exports.server.LogLevel.verbose)) {
          logger.info("".concat(cacheKey, " for path ").concat(path, " not found in cache..."));
        }

        try {
          var args = [(0, typescript_exports.combinePaths)(libDirectory, "watchGuard.js"), path];

          if (logger.hasLevel(typescript_exports.server.LogLevel.verbose)) {
            logger.info("Starting ".concat(process.execPath, " with args:").concat(typescript_exports.server.stringifyIndented(args)));
          }

          import_child_process["default"].execFileSync(process.execPath, args, {
            stdio: "ignore",
            env: {
              ELECTRON_RUN_AS_NODE: "1"
            }
          });
          status = true;

          if (logger.hasLevel(typescript_exports.server.LogLevel.verbose)) {
            logger.info("WatchGuard for path ".concat(path, " returned: OK"));
          }
        } catch (e) {
          status = false;

          if (logger.hasLevel(typescript_exports.server.LogLevel.verbose)) {
            logger.info("WatchGuard for path ".concat(path, " returned: ").concat(e.message));
          }
        }

        if (cacheKey) {
          statusCache.set(cacheKey, status);
        }
      } else if (logger.hasLevel(typescript_exports.server.LogLevel.verbose)) {
        logger.info("watchDirectory for ".concat(path, " uses cached drive information."));
      }

      if (status) {
        return watchDirectorySwallowingException(path, callback, recursive, options);
      } else {
        return typescript_exports.noopFileWatcher;
      }
    };
  } else {
    sys4.watchDirectory = watchDirectorySwallowingException;
  }

  sys4.write = function (s) {
    return writeMessage(Buffer.from(s, "utf8"));
  };

  sys4.setTimeout = setTimeout;
  sys4.clearTimeout = clearTimeout;
  sys4.setImmediate = setImmediate;
  sys4.clearImmediate = clearImmediate;

  if (typeof global !== "undefined" && global.gc) {
    sys4.gc = function () {
      var _a;

      return (_a = global.gc) == null ? void 0 : _a.call(global);
    };
  }

  var cancellationToken;

  try {
    var factory = require("./cancellationToken.js");

    cancellationToken = factory(sys4.args);
  } catch (_unused2) {
    cancellationToken = typescript_exports.server.nullCancellationToken;
  }

  var localeStr = typescript_exports.server.findArgument("--locale");

  if (localeStr) {
    (0, typescript_exports.validateLocaleAndSetLanguage)(localeStr, sys4);
  }

  var modeOrUnknown = parseServerMode();
  var serverMode;
  var unknownServerMode;

  if (modeOrUnknown !== void 0) {
    if (typeof modeOrUnknown === "number") serverMode = modeOrUnknown;else unknownServerMode = modeOrUnknown;
  }

  return {
    args: process.argv,
    logger: logger,
    cancellationToken: cancellationToken,
    serverMode: serverMode,
    unknownServerMode: unknownServerMode,
    startSession: startNodeSession
  };

  function createLogger() {
    var cmdLineLogFileName = typescript_exports.server.findArgument("--logFile");
    var cmdLineVerbosity = getLogLevel(typescript_exports.server.findArgument("--logVerbosity"));
    var envLogOptions = parseLoggingEnvironmentString(process.env.TSS_LOG);
    var unsubstitutedLogFileName = cmdLineLogFileName ? (0, typescript_exports.stripQuotes)(cmdLineLogFileName) : envLogOptions.logToFile ? envLogOptions.file || libDirectory + "/.log" + process.pid.toString() : void 0;
    var substitutedLogFileName = unsubstitutedLogFileName ? unsubstitutedLogFileName.replace("PID", process.pid.toString()) : void 0;
    var logVerbosity = cmdLineVerbosity || envLogOptions.detailLevel;
    return new Logger(substitutedLogFileName, envLogOptions.traceToConsole, logVerbosity);
  }

  function writeMessage(buf) {
    if (!canWrite) {
      pending.enqueue(buf);
    } else {
      canWrite = false;
      process.stdout.write(buf, setCanWriteFlagAndWriteMessageIfNecessary);
    }
  }

  function setCanWriteFlagAndWriteMessageIfNecessary() {
    canWrite = true;

    if (!pending.isEmpty()) {
      writeMessage(pending.dequeue());
    }
  }

  function extractWatchDirectoryCacheKey(path, currentDriveKey) {
    path = (0, typescript_exports.normalizeSlashes)(path);

    if (isUNCPath(path)) {
      var firstSlash = path.indexOf(typescript_exports.directorySeparator, 2);
      return firstSlash !== -1 ? (0, typescript_exports.toFileNameLowerCase)(path.substring(0, firstSlash)) : path;
    }

    var rootLength = (0, typescript_exports.getRootLength)(path);

    if (rootLength === 0) {
      return currentDriveKey;
    }

    if (path.charCodeAt(1) === typescript_exports.CharacterCodes.colon && path.charCodeAt(2) === typescript_exports.CharacterCodes.slash) {
      return (0, typescript_exports.toFileNameLowerCase)(path.charAt(0));
    }

    if (path.charCodeAt(0) === typescript_exports.CharacterCodes.slash && path.charCodeAt(1) !== typescript_exports.CharacterCodes.slash) {
      return currentDriveKey;
    }

    return void 0;
  }

  function isUNCPath(s) {
    return s.length > 2 && s.charCodeAt(0) === typescript_exports.CharacterCodes.slash && s.charCodeAt(1) === typescript_exports.CharacterCodes.slash;
  }

  function watchDirectorySwallowingException(path, callback, recursive, options) {
    try {
      return originalWatchDirectory(path, callback, recursive, options);
    } catch (e) {
      logger.info("Exception when creating directory watcher: ".concat(e.message));
      return typescript_exports.noopFileWatcher;
    }
  }
}

function parseEventPort(eventPortStr) {
  var eventPort = eventPortStr === void 0 ? void 0 : parseInt(eventPortStr);
  return eventPort !== void 0 && !isNaN(eventPort) ? eventPort : void 0;
}

function startNodeSession(options, logger, cancellationToken) {
  var rl = import_readline["default"].createInterface({
    input: process.stdin,
    output: process.stdout,
    terminal: false
  });

  var _NodeTypingsInstallerAdapter =
  /*#__PURE__*/
  function (_typescript_exports$s) {
    _inherits(_NodeTypingsInstallerAdapter, _typescript_exports$s);

    function _NodeTypingsInstallerAdapter(telemetryEnabled2, logger2, host, globalTypingsCacheLocation, typingSafeListLocation2, typesMapLocation2, npmLocation2, validateDefaultNpmLocation2, event) {
      var _this;

      _classCallCheck(this, _NodeTypingsInstallerAdapter);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(_NodeTypingsInstallerAdapter).call(this, telemetryEnabled2, logger2, host, globalTypingsCacheLocation, event, _NodeTypingsInstallerAdapter.maxActiveRequestCount));
      _this.typingSafeListLocation = typingSafeListLocation2;
      _this.typesMapLocation = typesMapLocation2;
      _this.npmLocation = npmLocation2;
      _this.validateDefaultNpmLocation = validateDefaultNpmLocation2;
      return _this;
    }

    _createClass(_NodeTypingsInstallerAdapter, [{
      key: "createInstallerProcess",
      value: function createInstallerProcess() {
        var _this2 = this;

        if (this.logger.hasLevel(typescript_exports.server.LogLevel.requestTime)) {
          this.logger.info("Binding...");
        }

        var args = [typescript_exports.server.Arguments.GlobalCacheLocation, this.globalTypingsCacheLocation];

        if (this.telemetryEnabled) {
          args.push(typescript_exports.server.Arguments.EnableTelemetry);
        }

        if (this.logger.loggingEnabled() && this.logger.getLogFileName()) {
          args.push(typescript_exports.server.Arguments.LogFile, (0, typescript_exports.combinePaths)((0, typescript_exports.getDirectoryPath)((0, typescript_exports.normalizeSlashes)(this.logger.getLogFileName())), "ti-".concat(process.pid, ".log")));
        }

        if (this.typingSafeListLocation) {
          args.push(typescript_exports.server.Arguments.TypingSafeListLocation, this.typingSafeListLocation);
        }

        if (this.typesMapLocation) {
          args.push(typescript_exports.server.Arguments.TypesMapLocation, this.typesMapLocation);
        }

        if (this.npmLocation) {
          args.push(typescript_exports.server.Arguments.NpmLocation, this.npmLocation);
        }

        if (this.validateDefaultNpmLocation) {
          args.push(typescript_exports.server.Arguments.ValidateDefaultNpmLocation);
        }

        var execArgv = [];
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = process.execArgv[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var arg = _step2.value;
            var match = /^--((?:debug|inspect)(?:-brk)?)(?:=(\d+))?$/.exec(arg);

            if (match) {
              var currentPort = match[2] !== void 0 ? +match[2] : match[1].charAt(0) === "d" ? 5858 : 9229;
              execArgv.push("--".concat(match[1], "=").concat(currentPort + 1));
              break;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        var typingsInstaller = (0, typescript_exports.combinePaths)((0, typescript_exports.getDirectoryPath)(typescript_exports.sys.getExecutingFilePath()), "typingsInstaller.js");
        this.installer = import_child_process["default"].fork(typingsInstaller, args, {
          execArgv: execArgv
        });
        this.installer.on("message", function (m) {
          return _this2.handleMessage(m);
        });
        this.host.setImmediate(function () {
          return _this2.event({
            pid: _this2.installer.pid
          }, "typingsInstallerPid");
        });
        process.on("exit", function () {
          _this2.installer.kill();
        });
        return this.installer;
      }
    }]);

    return _NodeTypingsInstallerAdapter;
  }(typescript_exports.server.TypingsInstallerAdapter); // This number is essentially arbitrary.  Processing more than one typings request
  // at a time makes sense, but having too many in the pipe results in a hang
  // (see https://github.com/nodejs/node/issues/7657).
  // It would be preferable to base our limit on the amount of space left in the
  // buffer, but we have yet to find a way to retrieve that value.


  _NodeTypingsInstallerAdapter.maxActiveRequestCount = 10;
  var NodeTypingsInstallerAdapter = _NodeTypingsInstallerAdapter;

  var IOSession =
  /*#__PURE__*/
  function (_typescript_exports$s2) {
    _inherits(IOSession, _typescript_exports$s2);

    function IOSession() {
      var _this3;

      _classCallCheck(this, IOSession);

      var event = function event(body, eventName) {
        _this3.event(body, eventName);
      };

      var host = typescript_exports.sys;
      var typingsInstaller = disableAutomaticTypingAcquisition ? void 0 : new NodeTypingsInstallerAdapter(telemetryEnabled, logger, host, getGlobalTypingsCacheLocation(), typingSafeListLocation, typesMapLocation, npmLocation, validateDefaultNpmLocation, event);
      _this3 = _possibleConstructorReturn(this, _getPrototypeOf(IOSession).call(this, _objectSpread({
        host: host,
        cancellationToken: cancellationToken
      }, options, {
        typingsInstaller: typingsInstaller,
        byteLength: Buffer.byteLength,
        hrtime: process.hrtime,
        logger: logger,
        canUseEvents: true,
        typesMapLocation: typesMapLocation
      })));
      _this3.eventPort = eventPort;

      if (_this3.canUseEvents && _this3.eventPort) {
        var s = import_net["default"].connect({
          port: _this3.eventPort
        }, function () {
          _this3.eventSocket = s;

          if (_this3.socketEventQueue) {
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = _this3.socketEventQueue[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var event2 = _step3.value;

                _this3.writeToEventSocket(event2.body, event2.eventName);
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                  _iterator3["return"]();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            _this3.socketEventQueue = void 0;
          }
        });
      }

      _this3.constructed = true;
      return _this3;
    }

    _createClass(IOSession, [{
      key: "event",
      value: function event(body, eventName) {
        typescript_exports.Debug.assert(!!this.constructed, "Should only call `IOSession.prototype.event` on an initialized IOSession");

        if (this.canUseEvents && this.eventPort) {
          if (!this.eventSocket) {
            if (this.logger.hasLevel(typescript_exports.server.LogLevel.verbose)) {
              this.logger.info("eventPort: event \"".concat(eventName, "\" queued, but socket not yet initialized"));
            }

            (this.socketEventQueue || (this.socketEventQueue = [])).push({
              body: body,
              eventName: eventName
            });
            return;
          } else {
            typescript_exports.Debug.assert(this.socketEventQueue === void 0);
            this.writeToEventSocket(body, eventName);
          }
        } else {
          _get(_getPrototypeOf(IOSession.prototype), "event", this).call(this, body, eventName);
        }
      }
    }, {
      key: "writeToEventSocket",
      value: function writeToEventSocket(body, eventName) {
        this.eventSocket.write(typescript_exports.server.formatMessage(typescript_exports.server.toEvent(eventName, body), this.logger, this.byteLength, this.host.newLine), "utf8");
      }
    }, {
      key: "exit",
      value: function exit() {
        var _a;

        this.logger.info("Exiting...");
        this.projectService.closeLog();
        (_a = typescript_exports.tracing) == null ? void 0 : _a.stopTracing();
        process.exit(0);
      }
    }, {
      key: "listen",
      value: function listen() {
        var _this4 = this;

        rl.on("line", function (input) {
          var message = input.trim();

          _this4.onMessage(message);
        });
        rl.on("close", function () {
          _this4.exit();
        });
      }
    }]);

    return IOSession;
  }(typescript_exports.server.Session);

  var IpcIOSession =
  /*#__PURE__*/
  function (_IOSession) {
    _inherits(IpcIOSession, _IOSession);

    function IpcIOSession() {
      _classCallCheck(this, IpcIOSession);

      return _possibleConstructorReturn(this, _getPrototypeOf(IpcIOSession).apply(this, arguments));
    }

    _createClass(IpcIOSession, [{
      key: "writeMessage",
      value: function writeMessage(msg) {
        var verboseLogging = logger.hasLevel(typescript_exports.server.LogLevel.verbose);

        if (verboseLogging) {
          var json = JSON.stringify(msg);
          logger.info("".concat(msg.type, ":").concat(typescript_exports.server.indent(json)));
        }

        process.send(msg);
      }
    }, {
      key: "parseMessage",
      value: function parseMessage(message) {
        return message;
      }
    }, {
      key: "toStringMessage",
      value: function toStringMessage(message) {
        return JSON.stringify(message, void 0, 2);
      }
    }, {
      key: "listen",
      value: function listen() {
        var _this5 = this;

        process.on("message", function (e) {
          _this5.onMessage(e);
        });
        process.on("disconnect", function () {
          _this5.exit();
        });
      }
    }]);

    return IpcIOSession;
  }(IOSession);

  var eventPort = parseEventPort(typescript_exports.server.findArgument("--eventPort"));
  var typingSafeListLocation = typescript_exports.server.findArgument(typescript_exports.server.Arguments.TypingSafeListLocation);
  var typesMapLocation = typescript_exports.server.findArgument(typescript_exports.server.Arguments.TypesMapLocation) || (0, typescript_exports.combinePaths)((0, typescript_exports.getDirectoryPath)(typescript_exports.sys.getExecutingFilePath()), "typesMap.json");
  var npmLocation = typescript_exports.server.findArgument(typescript_exports.server.Arguments.NpmLocation);
  var validateDefaultNpmLocation = typescript_exports.server.hasArgument(typescript_exports.server.Arguments.ValidateDefaultNpmLocation);
  var disableAutomaticTypingAcquisition = typescript_exports.server.hasArgument("--disableAutomaticTypingAcquisition");
  var useNodeIpc = typescript_exports.server.hasArgument("--useNodeIpc");
  var telemetryEnabled = typescript_exports.server.hasArgument(typescript_exports.server.Arguments.EnableTelemetry);
  var commandLineTraceDir = typescript_exports.server.findArgument("--traceDirectory");
  var traceDir = commandLineTraceDir ? (0, typescript_exports.stripQuotes)(commandLineTraceDir) : process.env.TSS_TRACE;

  if (traceDir) {
    (0, typescript_exports.startTracing)("server", traceDir);
  }

  var ioSession = useNodeIpc ? new IpcIOSession() : new IOSession();
  process.on("uncaughtException", function (err) {
    ioSession.logError(err, "unknown");
  });
  process.noAsar = true;
  ioSession.listen();

  function getGlobalTypingsCacheLocation() {
    switch (process.platform) {
      case "win32":
        {
          var basePath = process.env.LOCALAPPDATA || process.env.APPDATA || import_os["default"].homedir && import_os["default"].homedir() || process.env.USERPROFILE || process.env.HOMEDRIVE && process.env.HOMEPATH && (0, typescript_exports.normalizeSlashes)(process.env.HOMEDRIVE + process.env.HOMEPATH) || import_os["default"].tmpdir();
          return (0, typescript_exports.combinePaths)((0, typescript_exports.combinePaths)((0, typescript_exports.normalizeSlashes)(basePath), "Microsoft/TypeScript"), typescript_exports.versionMajorMinor);
        }

      case "openbsd":
      case "freebsd":
      case "netbsd":
      case "darwin":
      case "linux":
      case "android":
        {
          var cacheLocation = getNonWindowsCacheLocation(process.platform === "darwin");
          return (0, typescript_exports.combinePaths)((0, typescript_exports.combinePaths)(cacheLocation, "typescript"), typescript_exports.versionMajorMinor);
        }

      default:
        return typescript_exports.Debug.fail("unsupported platform '".concat(process.platform, "'"));
    }
  }

  function getNonWindowsCacheLocation(platformIsDarwin) {
    if (process.env.XDG_CACHE_HOME) {
      return process.env.XDG_CACHE_HOME;
    }

    var usersDir = platformIsDarwin ? "Users" : "home";
    var homePath = import_os["default"].homedir && import_os["default"].homedir() || process.env.HOME || (process.env.LOGNAME || process.env.USER) && "/".concat(usersDir, "/").concat(process.env.LOGNAME || process.env.USER) || import_os["default"].tmpdir();
    var cacheFolder = platformIsDarwin ? "Library/Caches" : ".cache";
    return (0, typescript_exports.combinePaths)((0, typescript_exports.normalizeSlashes)(homePath), cacheFolder);
  }
} // src/tsserver/server.ts


function findArgumentStringArray(argName) {
  var arg = typescript_exports.server.findArgument(argName);

  if (arg === void 0) {
    return typescript_exports.emptyArray;
  }

  return arg.split(",").filter(function (name) {
    return name !== "";
  });
}

function start(_ref, platform) {
  var args = _ref.args,
      logger = _ref.logger,
      cancellationToken = _ref.cancellationToken,
      serverMode = _ref.serverMode,
      unknownServerMode = _ref.unknownServerMode,
      startServer = _ref.startSession;
  logger.info("Starting TS Server");
  logger.info("Version: ".concat(typescript_exports.version));
  logger.info("Arguments: ".concat(args.join(" ")));
  logger.info("Platform: ".concat(platform, " NodeVersion: ").concat(process.version, " CaseSensitive: ").concat(typescript_exports.sys.useCaseSensitiveFileNames));
  logger.info("ServerMode: ".concat(serverMode, " hasUnknownServerMode: ").concat(unknownServerMode));
  typescript_exports.setStackTraceLimit();

  if (typescript_exports.Debug.isDebugging) {
    typescript_exports.Debug.enableDebugInfo();
  }

  if (typescript_exports.sys.tryEnableSourceMapsForHost && /^development$/i.test(typescript_exports.sys.getEnvironmentVariable("NODE_ENV"))) {
    typescript_exports.sys.tryEnableSourceMapsForHost();
  }

  console.log = function () {
    for (var _len = arguments.length, args2 = new Array(_len), _key = 0; _key < _len; _key++) {
      args2[_key] = arguments[_key];
    }

    return logger.msg(args2.length === 1 ? args2[0] : args2.join(", "), typescript_exports.server.Msg.Info);
  };

  console.warn = function () {
    for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args2[_key2] = arguments[_key2];
    }

    return logger.msg(args2.length === 1 ? args2[0] : args2.join(", "), typescript_exports.server.Msg.Err);
  };

  console.error = function () {
    for (var _len3 = arguments.length, args2 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args2[_key3] = arguments[_key3];
    }

    return logger.msg(args2.length === 1 ? args2[0] : args2.join(", "), typescript_exports.server.Msg.Err);
  };

  startServer({
    globalPlugins: findArgumentStringArray("--globalPlugins"),
    pluginProbeLocations: findArgumentStringArray("--pluginProbeLocations"),
    allowLocalPluginLoads: typescript_exports.server.hasArgument("--allowLocalPluginLoads"),
    useSingleInferredProject: typescript_exports.server.hasArgument("--useSingleInferredProject"),
    useInferredProjectPerProjectRoot: typescript_exports.server.hasArgument("--useInferredProjectPerProjectRoot"),
    suppressDiagnosticEvents: typescript_exports.server.hasArgument("--suppressDiagnosticEvents"),
    noGetErrOnBackgroundUpdate: typescript_exports.server.hasArgument("--noGetErrOnBackgroundUpdate"),
    canUseWatchEvents: typescript_exports.server.hasArgument("--canUseWatchEvents"),
    serverMode: serverMode
  }, logger, cancellationToken);
}

typescript_exports.setStackTraceLimit();
start(initializeNodeSystem(), import_os2["default"].platform());